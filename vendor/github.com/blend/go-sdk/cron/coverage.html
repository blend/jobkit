
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/blend/go-sdk/cron/cancellation.go (100.0%)</option>
				
				<option value="file1">github.com/blend/go-sdk/cron/context.go (71.4%)</option>
				
				<option value="file2">github.com/blend/go-sdk/cron/daily_schedule.go (56.0%)</option>
				
				<option value="file3">github.com/blend/go-sdk/cron/default.go (100.0%)</option>
				
				<option value="file4">github.com/blend/go-sdk/cron/errors.go (80.0%)</option>
				
				<option value="file5">github.com/blend/go-sdk/cron/event.go (72.7%)</option>
				
				<option value="file6">github.com/blend/go-sdk/cron/immediate_schedule.go (100.0%)</option>
				
				<option value="file7">github.com/blend/go-sdk/cron/interval_schedule.go (100.0%)</option>
				
				<option value="file8">github.com/blend/go-sdk/cron/job_builder.go (55.1%)</option>
				
				<option value="file9">github.com/blend/go-sdk/cron/job_config.go (85.2%)</option>
				
				<option value="file10">github.com/blend/go-sdk/cron/job_invocation.go (94.3%)</option>
				
				<option value="file11">github.com/blend/go-sdk/cron/job_manager.go (86.0%)</option>
				
				<option value="file12">github.com/blend/go-sdk/cron/job_manager_option.go (100.0%)</option>
				
				<option value="file13">github.com/blend/go-sdk/cron/job_scheduler.go (86.2%)</option>
				
				<option value="file14">github.com/blend/go-sdk/cron/job_scheduler_option.go (100.0%)</option>
				
				<option value="file15">github.com/blend/go-sdk/cron/on_the_hour_at.go (76.9%)</option>
				
				<option value="file16">github.com/blend/go-sdk/cron/once_at.go (71.4%)</option>
				
				<option value="file17">github.com/blend/go-sdk/cron/sort.go (50.0%)</option>
				
				<option value="file18">github.com/blend/go-sdk/cron/string_schedule.go (66.9%)</option>
				
				<option value="file19">github.com/blend/go-sdk/cron/util.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cron

import "context"

// IsContextCancelled check if a job is cancelled
func IsContextCancelled(ctx context.Context) bool <span class="cov10" title="2">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cron

import (
        "context"

        "github.com/blend/go-sdk/uuid"
)

type jobInvocationKey struct{}

// NewJobInvocationID returns a new pseudo-unique job invocation identifier.
func NewJobInvocationID() string <span class="cov10" title="19">{
        return uuid.V4().String()
}</span>

// WithJobInvocation adds a job invocation to a context as a value.
func WithJobInvocation(ctx context.Context, ji *JobInvocation) context.Context <span class="cov9" title="16">{
        return context.WithValue(ctx, jobInvocationKey{}, ji)
}</span>

// GetJobInvocation returns the job invocation ID from a context.
func GetJobInvocation(ctx context.Context) *JobInvocation <span class="cov5" title="4">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="4">if ji, ok := ctx.Value(jobInvocationKey{}).(*JobInvocation); ok </span><span class="cov5" title="4">{
                return ji
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cron

import (
        "fmt"
        "strings"
        "time"
)

var (
        _ Schedule     = (*DailySchedule)(nil)
        _ fmt.Stringer = (*DailySchedule)(nil)
)

// WeeklyAtUTC returns a schedule that fires on every of the given days at the given time by hour, minute and second in UTC.
func WeeklyAtUTC(hour, minute, second int, days ...time.Weekday) Schedule <span class="cov1" title="1">{
        dayOfWeekMask := uint(0)
        for _, day := range days </span><span class="cov1" title="1">{
                dayOfWeekMask = dayOfWeekMask | 1&lt;&lt;uint(day)
        }</span>

        <span class="cov1" title="1">return &amp;DailySchedule{DayOfWeekMask: dayOfWeekMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}</span>
}

// DailyAtUTC returns a schedule that fires every day at the given hour, minute and second in UTC.
func DailyAtUTC(hour, minute, second int) Schedule <span class="cov1" title="1">{
        return &amp;DailySchedule{DayOfWeekMask: AllDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// WeekdaysAtUTC returns a schedule that fires every week day at the given hour, minute and second in UTC&gt;
func WeekdaysAtUTC(hour, minute, second int) Schedule <span class="cov0" title="0">{
        return &amp;DailySchedule{DayOfWeekMask: WeekDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// WeekendsAtUTC returns a schedule that fires every weekend day at the given hour, minut and second.
func WeekendsAtUTC(hour, minute, second int) Schedule <span class="cov0" title="0">{
        return &amp;DailySchedule{DayOfWeekMask: WeekendDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// DailySchedule is a schedule that fires every day that satisfies the DayOfWeekMask at the given TimeOfDayUTC.
type DailySchedule struct {
        DayOfWeekMask uint
        TimeOfDayUTC  time.Time
}

func (ds DailySchedule) String() string <span class="cov0" title="0">{
        if ds.DayOfWeekMask &gt; 0 </span><span class="cov0" title="0">{
                var days []string
                for _, d := range DaysOfWeek </span><span class="cov0" title="0">{
                        if ds.checkDayOfWeekMask(d) </span><span class="cov0" title="0">{
                                days = append(days, d.String())
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("%s on %s each week", ds.TimeOfDayUTC.Format(time.RFC3339), strings.Join(days, ", "))</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s every day", ds.TimeOfDayUTC.Format(time.RFC3339))</span>
}

func (ds DailySchedule) checkDayOfWeekMask(day time.Weekday) bool <span class="cov10" title="12">{
        trialDayMask := uint(1 &lt;&lt; uint(day))
        bitwiseResult := (ds.DayOfWeekMask &amp; trialDayMask)
        return bitwiseResult &gt; uint(0)
}</span>

// Next implements Schedule.
func (ds DailySchedule) Next(after time.Time) time.Time <span class="cov6" title="4">{
        if after.IsZero() </span><span class="cov0" title="0">{
                after = Now()
        }</span>

        <span class="cov6" title="4">todayInstance := time.Date(after.Year(), after.Month(), after.Day(), ds.TimeOfDayUTC.Hour(), ds.TimeOfDayUTC.Minute(), ds.TimeOfDayUTC.Second(), 0, time.UTC)
        for day := 0; day &lt; 8; day++ </span><span class="cov10" title="12">{
                next := todayInstance.AddDate(0, 0, day) //the first run here it should be adding nothing, i.e. returning todayInstance ...

                if ds.checkDayOfWeekMask(next.Weekday()) &amp;&amp; next.After(after) </span><span class="cov6" title="4">{ //we're on a day ...
                        return next
                }</span>
        }

        <span class="cov0" title="0">return Zero</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cron

import "sync"

var (
        _default     *JobManager
        _defaultLock sync.Mutex
)

// Default returns a shared instance of a JobManager.
// If unset, it will initialize it with `New()`.
func Default() *JobManager <span class="cov8" title="1">{
        if _default == nil </span><span class="cov8" title="1">{
                _defaultLock.Lock()
                defer _defaultLock.Unlock()

                if _default == nil </span><span class="cov8" title="1">{
                        _default = New()
                }</span>
        }
        <span class="cov8" title="1">return _default</span>
}

// SetDefault sets the default job manager.
func SetDefault(jm *JobManager) <span class="cov8" title="1">{
        _defaultLock.Lock()
        _default = jm
        _defaultLock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cron

import "github.com/blend/go-sdk/ex"

const (
        // ErrJobNotLoaded is a common error.
        ErrJobNotLoaded ex.Class = "job not loaded"

        // ErrJobAlreadyLoaded is a common error.
        ErrJobAlreadyLoaded ex.Class = "job already loaded"

        // ErrJobNotFound is a common error.
        ErrJobNotFound ex.Class = "job not found"

        // ErrJobCancelled is a common error.
        ErrJobCancelled ex.Class = "job cancelled"

        // ErrJobAlreadyRunning is a common error.
        ErrJobAlreadyRunning ex.Class = "job already running"
)

// IsJobNotLoaded returns if the error is a job not loaded error.
func IsJobNotLoaded(err error) bool <span class="cov10" title="4">{
        return ex.Is(err, ErrJobNotLoaded)
}</span>

// IsJobAlreadyLoaded returns if the error is a job already loaded error.
func IsJobAlreadyLoaded(err error) bool <span class="cov10" title="4">{
        return ex.Is(err, ErrJobAlreadyLoaded)
}</span>

// IsJobNotFound returns if the error is a task not found error.
func IsJobNotFound(err error) bool <span class="cov10" title="4">{
        return ex.Is(err, ErrJobNotFound)
}</span>

// IsJobCancelled returns if the error is a task not found error.
func IsJobCancelled(err error) bool <span class="cov10" title="4">{
        return ex.Is(err, ErrJobCancelled)
}</span>

// IsJobAlreadyRunning returns if the error is a task not found error.
func IsJobAlreadyRunning(err error) bool <span class="cov0" title="0">{
        return ex.Is(err, ErrJobAlreadyRunning)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cron

import (
        "context"
        "fmt"
        "io"
        "time"

        "github.com/blend/go-sdk/ansi"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/timeutil"
)

// these are compile time assertions
var (
        _ logger.Event        = (*Event)(nil)
        _ logger.TextWritable = (*Event)(nil)
        _ logger.JSONWritable = (*Event)(nil)
)

// NewEventListener returns a new event listener.
func NewEventListener(listener func(context.Context, Event)) logger.Listener <span class="cov0" title="0">{
        return func(ctx context.Context, e logger.Event) </span><span class="cov0" title="0">{
                if typed, isTyped := e.(Event); isTyped </span><span class="cov0" title="0">{
                        listener(ctx, typed)
                }</span>
        }
}

// NewEvent creates a new event with a given set of optional options.
func NewEvent(flag, jobName string, options ...EventOption) Event <span class="cov7" title="4">{
        e := Event{
                Flag:    flag,
                JobName: jobName,
        }

        for _, option := range options </span><span class="cov8" title="5">{
                option(&amp;e)
        }</span>
        <span class="cov7" title="4">return e</span>
}

// EventOption is an option for an Event.
type EventOption func(*Event)

// OptEventJobInvocation sets a field.
func OptEventJobInvocation(jobInvocation string) EventOption <span class="cov4" title="2">{
        return func(e *Event) </span><span class="cov4" title="2">{ e.JobInvocation = jobInvocation }</span>
}

// OptEventErr sets a field.
func OptEventErr(err error) EventOption <span class="cov1" title="1">{
        return func(e *Event) </span><span class="cov1" title="1">{ e.Err = err }</span>
}

// OptEventElapsed sets a field.
func OptEventElapsed(elapsed time.Duration) EventOption <span class="cov4" title="2">{
        return func(e *Event) </span><span class="cov4" title="2">{ e.Elapsed = elapsed }</span>
}

// Event is an event.
type Event struct {
        Flag          string
        JobName       string
        JobInvocation string
        Err           error
        Elapsed       time.Duration
}

// GetFlag implements logger.Event.
func (e Event) GetFlag() string <span class="cov10" title="7">{ return e.Flag }</span>

// Complete returns if the event completed.
func (e Event) Complete() bool <span class="cov0" title="0">{
        return e.Flag == FlagComplete
}</span>

// WriteText implements logger.TextWritable.
func (e Event) WriteText(tf logger.TextFormatter, wr io.Writer) <span class="cov4" title="2">{
        if e.JobInvocation != "" </span><span class="cov4" title="2">{
                io.WriteString(wr, fmt.Sprintf("[%s &gt; %s]", tf.Colorize(e.JobName, ansi.ColorBlue), tf.Colorize(e.JobInvocation, ansi.ColorBlue)))
        }</span> else<span class="cov0" title="0"> {
                io.WriteString(wr, fmt.Sprintf("[%s]", tf.Colorize(e.JobName, ansi.ColorBlue)))
        }</span>

        <span class="cov4" title="2">if e.Elapsed &gt; 0 </span><span class="cov1" title="1">{
                io.WriteString(wr, logger.Space)
                io.WriteString(wr, fmt.Sprintf("(%v)", e.Elapsed))
        }</span>
}

// Decompose implements logger.JSONWritable.
func (e Event) Decompose() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "jobName": e.JobName,
                "err":     e.Err,
                "elapsed": timeutil.Milliseconds(e.Elapsed),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package cron

import (
        "fmt"
        "sync/atomic"
        "time"
)

// Interface assertions.
var (
        _ Schedule     = (*ImmediateSchedule)(nil)
        _ fmt.Stringer = (*ImmediateSchedule)(nil)
)

// Immediately Returns a schedule that casues a job to run immediately on start,
// with an optional subsequent schedule.
func Immediately() *ImmediateSchedule <span class="cov4" title="2">{
        return &amp;ImmediateSchedule{}
}</span>

// ImmediateSchedule fires immediately with an optional continuation schedule.
type ImmediateSchedule struct {
        didRun int32
        then   Schedule
}

// String returns a string representation of the schedul.e
func (i ImmediateSchedule) String() string <span class="cov4" title="2">{
        if i.then != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("immediately, then %v", i.then)
        }</span>
        <span class="cov1" title="1">return "immediately, once"</span>
}

// Then allows you to specify a subsequent schedule after the first run.
func (i *ImmediateSchedule) Then(then Schedule) Schedule <span class="cov4" title="2">{
        i.then = then
        return i
}</span>

// Next implements Schedule.
func (i *ImmediateSchedule) Next(after time.Time) time.Time <span class="cov10" title="6">{
        if atomic.LoadInt32(&amp;i.didRun) == 0 </span><span class="cov6" title="3">{
                i.didRun = 1
                return Now()
        }</span>
        <span class="cov6" title="3">if i.then != nil </span><span class="cov4" title="2">{
                return i.then.Next(after)
        }</span>
        <span class="cov1" title="1">return Zero</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cron

import (
        "fmt"
        "time"
)

var (
        _ Schedule     = (*IntervalSchedule)(nil)
        _ fmt.Stringer = (*IntervalSchedule)(nil)
)

// EverySecond returns a schedule that fires every second.
func EverySecond() IntervalSchedule <span class="cov3" title="2">{
        return IntervalSchedule{Every: time.Second}
}</span>

// EveryMinute returns a schedule that fires every minute.
func EveryMinute() IntervalSchedule <span class="cov3" title="2">{
        return IntervalSchedule{Every: time.Minute}
}</span>

// EveryHour returns a schedule that fire every hour.
func EveryHour() IntervalSchedule <span class="cov5" title="3">{
        return IntervalSchedule{Every: time.Hour}
}</span>

// Every returns a schedule that fires every given interval.
func Every(interval time.Duration) IntervalSchedule <span class="cov3" title="2">{
        return IntervalSchedule{Every: interval}
}</span>

// EveryDelayed returns a schedule that fires every given interval
// with a start delay.
func EveryDelayed(interval, delay time.Duration) IntervalSchedule <span class="cov1" title="1">{
        return IntervalSchedule{Every: interval, StartDelay: delay}
}</span>

// IntervalSchedule is as chedule that fires every given interval with an optional start delay.
type IntervalSchedule struct {
        Every      time.Duration
        StartDelay time.Duration
}

// String returns a string representation of the schedule.
func (i IntervalSchedule) String() string <span class="cov5" title="3">{
        if i.StartDelay &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("every %v with an initial delay of %v", i.Every, i.StartDelay)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("every %v", i.Every)</span>
}

// Next implements Schedule.
func (i IntervalSchedule) Next(after time.Time) time.Time <span class="cov10" title="9">{
        if after.IsZero() </span><span class="cov5" title="3">{
                if i.StartDelay &gt; 0 </span><span class="cov1" title="1">{
                        return Now().Add(i.StartDelay).Add(i.Every)
                }</span>
                <span class="cov3" title="2">return Now().Add(i.Every)</span>
        }
        <span class="cov8" title="6">return after.Add(i.Every)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cron

import (
        "context"
        "time"

        "github.com/blend/go-sdk/stringutil"
)

// Interface assertions.
var (
        _ Job                                = (*JobBuilder)(nil)
        _ LabelsProvider                     = (*JobBuilder)(nil)
        _ ScheduleProvider                   = (*JobBuilder)(nil)
        _ TimeoutProvider                    = (*JobBuilder)(nil)
        _ ShutdownGracePeriodProvider        = (*JobBuilder)(nil)
        _ DisabledProvider                   = (*JobBuilder)(nil)
        _ ShouldSkipLoggerListenersProvider  = (*JobBuilder)(nil)
        _ ShouldSkipLoggerOutputProvider     = (*JobBuilder)(nil)
        _ OnStartReceiver                    = (*JobBuilder)(nil)
        _ OnCancellationReceiver             = (*JobBuilder)(nil)
        _ OnCompleteReceiver                 = (*JobBuilder)(nil)
        _ OnFailureReceiver                  = (*JobBuilder)(nil)
        _ OnBrokenReceiver                   = (*JobBuilder)(nil)
        _ OnFixedReceiver                    = (*JobBuilder)(nil)
        _ OnEnabledReceiver                  = (*JobBuilder)(nil)
        _ OnDisabledReceiver                 = (*JobBuilder)(nil)
        _ HistoryDisabledProvider            = (*JobBuilder)(nil)
        _ HistoryPersistenceDisabledProvider = (*JobBuilder)(nil)
        _ HistoryMaxCountProvider            = (*JobBuilder)(nil)
        _ HistoryMaxAgeProvider              = (*JobBuilder)(nil)
        _ HistoryProvider                    = (*JobBuilder)(nil)
)

// NewJob returns a new job builder.
func NewJob(options ...JobBuilderOption) *JobBuilder <span class="cov8" title="31">{
        var jb JobBuilder
        for _, option := range options </span><span class="cov9" title="37">{
                option(&amp;jb)
        }</span>
        <span class="cov8" title="31">if jb.Config.Name == "" </span><span class="cov6" title="9">{
                jb.Config.Name = stringutil.Random(stringutil.LowerLetters, 16)
        }</span>
        <span class="cov8" title="31">return &amp;jb</span>
}

// JobBuilderOption is a job builder option.
type JobBuilderOption func(*JobBuilder)

// OptJobName sets the job name.
func OptJobName(name string) JobBuilderOption <span class="cov8" title="22">{
        return func(jb *JobBuilder) </span><span class="cov8" title="22">{ jb.Config.Name = name }</span>
}

// OptJobAction sets the job action.
func OptJobAction(action func(context.Context) error) JobBuilderOption <span class="cov6" title="11">{
        return func(jb *JobBuilder) </span><span class="cov6" title="11">{ jb.Action = action }</span>
}

// OptJobLabels is a job builder sets the job labels.
func OptJobLabels(labels map[string]string) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.LabelsProvider = func() map[string]string </span><span class="cov0" title="0">{ return labels }</span> }
}

// OptJobSchedule is a job builder sets the job schedule provder.
func OptJobSchedule(schedule Schedule) JobBuilderOption <span class="cov1" title="1">{
        return func(jb *JobBuilder) </span><span class="cov1" title="1">{ jb.ScheduleProvider = func() Schedule </span><span class="cov1" title="1">{ return schedule }</span> }
}

// OptJobTimeout is a job builder sets the job timeout provder.
func OptJobTimeout(d time.Duration) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.TimeoutProvider = func() time.Duration </span><span class="cov0" title="0">{ return d }</span> }
}

// OptJobShutdownGracePeriod is a job builder sets the job shutdown grace period provder.
func OptJobShutdownGracePeriod(d time.Duration) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.ShutdownGracePeriodProvider = func() time.Duration </span><span class="cov0" title="0">{ return d }</span> }
}

// OptJobDisabled is a job builder sets the job timeout provder.
func OptJobDisabled(provider func() bool) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.DisabledProvider = provider }</span>
}

// OptJobOnStart is a job builder option implementation.
func OptJobOnStart(handler func(*JobInvocation)) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.OnStartHandler = handler }</span>
}

// OptJobOnCancellation is a job builder option implementation.
func OptJobOnCancellation(handler func(*JobInvocation)) JobBuilderOption <span class="cov1" title="1">{
        return func(jb *JobBuilder) </span><span class="cov1" title="1">{ jb.OnCancellationHandler = handler }</span>
}

// OptJobOnComplete is a job builder option implementation.
func OptJobOnComplete(handler func(*JobInvocation)) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.OnCompleteHandler = handler }</span>
}

// OptJobOnFailure is a job builder option implementation.
func OptJobOnFailure(handler func(*JobInvocation)) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.OnFailureHandler = handler }</span>
}

// OptJobOnBroken is a job builder option implementation.
func OptJobOnBroken(handler func(*JobInvocation)) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.OnBrokenHandler = handler }</span>
}

// OptJobOnFixed is a job builder option implementation.
func OptJobOnFixed(handler func(*JobInvocation)) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.OnFixedHandler = handler }</span>
}

// OptJobOnEnabled is a job builder option implementation.
func OptJobOnEnabled(handler func(context.Context)) JobBuilderOption <span class="cov1" title="1">{
        return func(jb *JobBuilder) </span><span class="cov1" title="1">{ jb.OnEnabledHandler = handler }</span>
}

// OptJobOnDisabled is a job builder option implementation.
func OptJobOnDisabled(handler func(context.Context)) JobBuilderOption <span class="cov1" title="1">{
        return func(jb *JobBuilder) </span><span class="cov1" title="1">{ jb.OnDisabledHandler = handler }</span>
}

// OptJobHistoryDisabled is a job builder option implementation.
func OptJobHistoryDisabled(provider func() bool) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.HistoryDisabledProvider = provider }</span>
}

// OptJobHistoryPersistenceDisabled is a job builder option implementation.
func OptJobHistoryPersistenceDisabled(provider func() bool) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.HistoryPersistenceDisabledProvider = provider }</span>
}

// OptJobHistoryMaxCount is a job builder option implementation.
func OptJobHistoryMaxCount(provider func() int) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.HistoryMaxCountProvider = provider }</span>
}

// OptJobHistoryMaxAge is a job builder option implementation.
func OptJobHistoryMaxAge(provider func() time.Duration) JobBuilderOption <span class="cov0" title="0">{
        return func(jb *JobBuilder) </span><span class="cov0" title="0">{ jb.HistoryMaxAgeProvider = provider }</span>
}

// JobBuilder allows for job creation w/o a fully formed struct.
type JobBuilder struct {
        Action Action
        Config JobConfig

        LabelsProvider                     func() map[string]string
        ScheduleProvider                   func() Schedule
        TimeoutProvider                    func() time.Duration
        ShutdownGracePeriodProvider        func() time.Duration
        DisabledProvider                   func() bool
        ShouldSkipLoggerListenersProvider  func() bool
        ShouldSkipLoggerOutputProvider     func() bool
        HistoryDisabledProvider            func() bool
        HistoryMaxCountProvider            func() int
        HistoryMaxAgeProvider              func() time.Duration
        HistoryPersistenceDisabledProvider func() bool

        OnStartHandler        func(*JobInvocation)
        OnCancellationHandler func(*JobInvocation)
        OnCompleteHandler     func(*JobInvocation)
        OnFailureHandler      func(*JobInvocation)
        OnBrokenHandler       func(*JobInvocation)
        OnFixedHandler        func(*JobInvocation)
        OnEnabledHandler      func(context.Context)
        OnDisabledHandler     func(context.Context)

        RestoreHistoryHandler func(context.Context) ([]JobInvocation, error)
        PersistHistoryHandler func(context.Context, []JobInvocation) error
}

//
// implementations of interface methods
//

// Name returns the job name.
func (jb *JobBuilder) Name() string <span class="cov10" title="48">{
        return jb.Config.Name
}</span>

// Labels returns the job labels.
func (jb *JobBuilder) Labels() map[string]string <span class="cov5" title="6">{
        if jb.LabelsProvider != nil </span><span class="cov0" title="0">{
                return jb.LabelsProvider()
        }</span>
        <span class="cov5" title="6">return jb.Config.Labels</span>
}

// Schedule returns the job schedule if a provider is set.
func (jb *JobBuilder) Schedule() Schedule <span class="cov8" title="23">{
        if jb.ScheduleProvider != nil </span><span class="cov1" title="1">{
                return jb.ScheduleProvider()
        }</span>
        <span class="cov8" title="22">return nil</span>
}

// Timeout returns the job timeout.
func (jb *JobBuilder) Timeout() time.Duration <span class="cov7" title="18">{
        if jb.TimeoutProvider != nil </span><span class="cov0" title="0">{
                return jb.TimeoutProvider()
        }</span>
        <span class="cov7" title="18">return jb.Config.TimeoutOrDefault()</span>
}

// ShutdownGracePeriod returns the shutdown grace period.
func (jb *JobBuilder) ShutdownGracePeriod() time.Duration <span class="cov2" title="2">{
        if jb.ShutdownGracePeriodProvider != nil </span><span class="cov0" title="0">{
                return jb.ShutdownGracePeriodProvider()
        }</span>
        <span class="cov2" title="2">return jb.Config.ShutdownGracePeriodOrDefault()</span>
}

// Disabled returns if the job is enabled.
func (jb *JobBuilder) Disabled() bool <span class="cov5" title="7">{
        if jb.DisabledProvider != nil </span><span class="cov0" title="0">{
                return jb.DisabledProvider()
        }</span>
        <span class="cov5" title="7">return jb.Config.DisabledOrDefault()</span>
}

// ShouldSkipLoggerListeners implements the should skip logger listeners provider.
func (jb *JobBuilder) ShouldSkipLoggerListeners() bool <span class="cov3" title="3">{
        if jb.ShouldSkipLoggerListenersProvider != nil </span><span class="cov0" title="0">{
                return jb.ShouldSkipLoggerListenersProvider()
        }</span>
        <span class="cov3" title="3">return jb.Config.ShouldSkipLoggerListenersOrDefault()</span>
}

// ShouldSkipLoggerOutput implements the should skip logger output provider.
func (jb *JobBuilder) ShouldSkipLoggerOutput() bool <span class="cov3" title="3">{
        if jb.ShouldSkipLoggerOutputProvider != nil </span><span class="cov0" title="0">{
                return jb.ShouldSkipLoggerOutputProvider()
        }</span>
        <span class="cov3" title="3">return jb.Config.ShouldSkipLoggerOutputOrDefault()</span>
}

// HistoryDisabled implements the history disabled provider.
func (jb *JobBuilder) HistoryDisabled() bool <span class="cov7" title="14">{
        if jb.HistoryDisabledProvider != nil </span><span class="cov0" title="0">{
                return jb.HistoryDisabledProvider()
        }</span>
        <span class="cov7" title="14">return jb.Config.HistoryDisabledOrDefault()</span>
}

// HistoryPersistenceDisabled implements the history disabled provider.
func (jb *JobBuilder) HistoryPersistenceDisabled() bool <span class="cov9" title="38">{
        if jb.HistoryPersistenceDisabledProvider != nil </span><span class="cov0" title="0">{
                return jb.HistoryPersistenceDisabledProvider()
        }</span>
        <span class="cov9" title="38">return jb.Config.HistoryPersistenceDisabledOrDefault()</span>
}

// HistoryMaxCount implements the history max count provider.
func (jb *JobBuilder) HistoryMaxCount() int <span class="cov7" title="16">{
        if jb.HistoryMaxCountProvider != nil </span><span class="cov0" title="0">{
                return jb.HistoryMaxCountProvider()
        }</span>
        <span class="cov7" title="16">return jb.Config.HistoryMaxCountOrDefault()</span>
}

// HistoryMaxAge implements the history max count provider.
func (jb *JobBuilder) HistoryMaxAge() time.Duration <span class="cov7" title="16">{
        if jb.HistoryMaxAgeProvider != nil </span><span class="cov0" title="0">{
                return jb.HistoryMaxAgeProvider()
        }</span>
        <span class="cov7" title="16">return jb.Config.HistoryMaxAgeOrDefault()</span>
}

// OnStart is a lifecycle hook.
func (jb *JobBuilder) OnStart(ctx context.Context) <span class="cov6" title="12">{
        if jb.OnStartHandler != nil </span><span class="cov0" title="0">{
                jb.OnStartHandler(GetJobInvocation(ctx))
        }</span>
}

// OnCancellation is a lifecycle hook.
func (jb *JobBuilder) OnCancellation(ctx context.Context) <span class="cov1" title="1">{
        if jb.OnCancellationHandler != nil </span><span class="cov1" title="1">{
                jb.OnCancellationHandler(GetJobInvocation(ctx))
        }</span>
}

// OnComplete is a lifecycle hook.
func (jb *JobBuilder) OnComplete(ctx context.Context) <span class="cov6" title="9">{
        if jb.OnCompleteHandler != nil </span><span class="cov0" title="0">{
                jb.OnCompleteHandler(GetJobInvocation(ctx))
        }</span>
}

// OnFailure is a lifecycle hook.
func (jb *JobBuilder) OnFailure(ctx context.Context) <span class="cov2" title="2">{
        if jb.OnFailureHandler != nil </span><span class="cov0" title="0">{
                jb.OnFailureHandler(GetJobInvocation(ctx))
        }</span>
}

// OnFixed is a lifecycle hook.
func (jb *JobBuilder) OnFixed(ctx context.Context) <span class="cov0" title="0">{
        if jb.OnFixedHandler != nil </span><span class="cov0" title="0">{
                jb.OnFixedHandler(GetJobInvocation(ctx))
        }</span>
}

// OnBroken is a lifecycle hook.
func (jb *JobBuilder) OnBroken(ctx context.Context) <span class="cov0" title="0">{
        if jb.OnBrokenHandler != nil </span><span class="cov0" title="0">{
                jb.OnBrokenHandler(GetJobInvocation(ctx))
        }</span>
}

// OnEnabled is a lifecycle hook.
func (jb *JobBuilder) OnEnabled(ctx context.Context) <span class="cov2" title="2">{
        if jb.OnEnabledHandler != nil </span><span class="cov1" title="1">{
                jb.OnEnabledHandler(ctx)
        }</span>
}

// OnDisabled is a lifecycle hook.
func (jb *JobBuilder) OnDisabled(ctx context.Context) <span class="cov2" title="2">{
        if jb.OnDisabledHandler != nil </span><span class="cov1" title="1">{
                jb.OnDisabledHandler(ctx)
        }</span>
}

// RestoreHistory calls the restore history handler if it's set.
func (jb *JobBuilder) RestoreHistory(ctx context.Context) ([]JobInvocation, error) <span class="cov7" title="17">{
        if jb.RestoreHistoryHandler != nil </span><span class="cov0" title="0">{
                return jb.RestoreHistoryHandler(ctx)
        }</span>
        <span class="cov7" title="17">return nil, nil</span>
}

// PersistHistory calls the persist history handler if it's set.
func (jb *JobBuilder) PersistHistory(ctx context.Context, history []JobInvocation) error <span class="cov6" title="11">{
        if jb.PersistHistoryHandler != nil </span><span class="cov0" title="0">{
                return jb.PersistHistoryHandler(ctx, history)
        }</span>
        <span class="cov6" title="11">return nil</span>
}

// Execute runs the job action if it's set.
func (jb *JobBuilder) Execute(ctx context.Context) error <span class="cov6" title="12">{
        if jb.Action != nil </span><span class="cov5" title="8">{
                return jb.Action(ctx)
        }</span>
        <span class="cov4" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cron

import "time"

// JobConfig is a configuration set for a job.
type JobConfig struct {
        // Name sets the job name.
        Name string `json:"name" yaml:"name"`
        // Disabled determines if the job should be automatically scheduled or not.
        Disabled *bool `json:"disabled" yaml:"disabled"`
        // Description is an optional string to describe what the job does.
        Description string `json:"description" yaml:"description"`
        // Labels define extra metadata that can be used to filter jobs.
        Labels map[string]string `json:"labels" yaml:"labels"`
        // Timeout represents the abort threshold for the job.
        Timeout time.Duration `json:"timeout" yaml:"timeout"`
        // ShutdownGracePeriod represents the time a job is given to clean itself up.
        ShutdownGracePeriod time.Duration `json:"shutdownGracePeriod" yaml:"shutdownGracePeriod"`
        // HistoryDisabled sets if we should save invocation history and restore it.
        HistoryDisabled *bool `json:"historyDisabled" yaml:"historyDisabled"`
        // HistoryPersistenceDisabled determines if we should save history to disk.
        HistoryPersistenceDisabled *bool `json:"historyPersistenceDisabled" yaml:"historyPersistenceDisabled"`
        // HistoryMaxCount is the maximum number of history items to keep.
        HistoryMaxCount int `json:"historyMaxCount" yaml:"historyMaxCount"`
        // HistoryMaxAge is the maximum age of history items to keep.
        HistoryMaxAge time.Duration `json:"historyMaxAge" yaml:"historyMaxAge"`

        // ShouldSkipLoggerListeners skips triggering logger events if it is set to true.
        ShouldSkipLoggerListeners *bool `json:"shouldSkipLoggerListeners" yaml:"shouldSkipLoggerListeners"`
        // ShouldSkipLoggerOutput skips writing logger output if it is set to true.
        ShouldSkipLoggerOutput *bool `json:"shouldSkipLoggerOutput" yaml:"shouldSkipLoggerOutput"`
}

// DisabledOrDefault returns a value or a default.
func (jc JobConfig) DisabledOrDefault() bool <span class="cov6" title="9">{
        if jc.Disabled != nil </span><span class="cov0" title="0">{
                return *jc.Disabled
        }</span>
        <span class="cov6" title="9">return DefaultDisabled</span>
}

// TimeoutOrDefault returns a value or a default.
func (jc JobConfig) TimeoutOrDefault() time.Duration <span class="cov8" title="25">{
        if jc.Timeout &gt; 0 </span><span class="cov1" title="1">{
                return jc.Timeout
        }</span>
        <span class="cov8" title="24">return DefaultTimeout</span>
}

// ShutdownGracePeriodOrDefault returns a value or a default.
func (jc JobConfig) ShutdownGracePeriodOrDefault() time.Duration <span class="cov4" title="4">{
        if jc.ShutdownGracePeriod &gt; 0 </span><span class="cov1" title="1">{
                return jc.ShutdownGracePeriod
        }</span>
        <span class="cov3" title="3">return DefaultShutdownGracePeriod</span>
}

// HistoryDisabledOrDefault returns a value or a default.
func (jc JobConfig) HistoryDisabledOrDefault() bool <span class="cov7" title="20">{
        if jc.HistoryDisabled != nil </span><span class="cov1" title="1">{
                return *jc.HistoryDisabled
        }</span>
        <span class="cov7" title="19">return DefaultHistoryDisabled</span>
}

// HistoryMaxCountOrDefault returns a value or a default.
func (jc JobConfig) HistoryMaxCountOrDefault() int <span class="cov8" title="22">{
        if jc.HistoryMaxCount &gt; 0 </span><span class="cov1" title="1">{
                return jc.HistoryMaxCount
        }</span>
        <span class="cov8" title="21">return 0</span>
}

// HistoryMaxAgeOrDefault returns a value or a default.
func (jc JobConfig) HistoryMaxAgeOrDefault() time.Duration <span class="cov8" title="22">{
        if jc.HistoryMaxAge &gt; 0 </span><span class="cov1" title="1">{
                return jc.HistoryMaxAge
        }</span>
        <span class="cov8" title="21">return 0</span>
}

// HistoryPersistenceDisabledOrDefault returns a value or a default.
func (jc JobConfig) HistoryPersistenceDisabledOrDefault() bool <span class="cov10" title="49">{
        if jc.HistoryPersistenceDisabled != nil </span><span class="cov0" title="0">{
                return *jc.HistoryPersistenceDisabled
        }</span>
        <span class="cov10" title="49">return DefaultHistoryPersistenceDisabled</span>
}

// ShouldSkipLoggerListenersOrDefault returns a value or a default.
func (jc JobConfig) ShouldSkipLoggerListenersOrDefault() bool <span class="cov4" title="4">{
        if jc.ShouldSkipLoggerListeners != nil </span><span class="cov0" title="0">{
                return *jc.ShouldSkipLoggerListeners
        }</span>
        <span class="cov4" title="4">return DefaultShouldSkipLoggerListeners</span>
}

// ShouldSkipLoggerOutputOrDefault returns a value or a default.
func (jc JobConfig) ShouldSkipLoggerOutputOrDefault() bool <span class="cov4" title="5">{
        if jc.ShouldSkipLoggerOutput != nil </span><span class="cov0" title="0">{
                return *jc.ShouldSkipLoggerOutput
        }</span>
        <span class="cov4" title="5">return DefaultShouldSkipLoggerOutput</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cron

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/blend/go-sdk/bufferutil"
        "github.com/blend/go-sdk/ex"
)

// NewJobInvocation returns a new job invocation.
func NewJobInvocation(jobName string) *JobInvocation <span class="cov10" title="19">{
        output := new(bufferutil.Buffer)
        handlers := new(bufferutil.BufferHandlers)
        output.Handler = handlers.Handle
        return &amp;JobInvocation{
                ID:             NewJobInvocationID(),
                Started:        Now(),
                State:          JobInvocationStateRunning,
                JobName:        jobName,
                Output:         output,
                OutputHandlers: handlers,
                Done:           make(chan struct{}),
        }
}</span>

// JobInvocation is metadata for a job invocation (or instance of a job running).
type JobInvocation struct {
        ID             string
        JobName        string
        Started        time.Time
        Finished       time.Time
        Cancelled      time.Time
        Timeout        time.Time
        Err            error
        Elapsed        time.Duration
        State          JobInvocationState
        Output         *bufferutil.Buffer
        OutputHandlers *bufferutil.BufferHandlers
        Context        context.Context
        Cancel         context.CancelFunc
        Done           chan struct{}
}

// MarshalJSON marshals the invocation as json.
func (ji JobInvocation) MarshalJSON() ([]byte, error) <span class="cov1" title="1">{
        values := map[string]interface{}{
                "id":      ji.ID,
                "jobName": ji.JobName,
                "started": ji.Started,
                "elapsed": ji.Elapsed,
                "state":   ji.State,
                "output":  ji.Output,
        }
        if !ji.Finished.IsZero() </span><span class="cov1" title="1">{
                values["finished"] = ji.Finished
        }</span>
        <span class="cov1" title="1">if !ji.Cancelled.IsZero() </span><span class="cov1" title="1">{
                values["cancelled"] = ji.Cancelled
        }</span>
        <span class="cov1" title="1">if !ji.Timeout.IsZero() </span><span class="cov1" title="1">{
                values["timeout"] = ji.Timeout
        }</span>
        <span class="cov1" title="1">if ji.Err != nil </span><span class="cov1" title="1">{
                values["err"] = ji.Err.Error()
        }</span>
        <span class="cov1" title="1">contents, err := json.Marshal(values)
        return contents, ex.New(err)</span>
}

// UnmarshalJSON unmarhsals
func (ji *JobInvocation) UnmarshalJSON(contents []byte) error <span class="cov1" title="1">{
        var values struct {
                ID        string             `json:"id"`
                JobName   string             `json:"jobName"`
                Started   time.Time          `json:"started"`
                Finished  time.Time          `json:"finished"`
                Cancelled time.Time          `json:"cancelled"`
                Timeout   time.Time          `json:"timeout"`
                Elapsed   time.Duration      `json:"elapsed"`
                State     JobInvocationState `json:"state"`
                Error     string             `json:"err"`
                Output    json.RawMessage    `json:"output"`
        }
        if err := json.Unmarshal(contents, &amp;values); err != nil </span><span class="cov0" title="0">{
                return ex.New(err)
        }</span>
        <span class="cov1" title="1">ji.ID = values.ID
        ji.JobName = values.JobName
        ji.Started = values.Started
        ji.Finished = values.Finished
        ji.Cancelled = values.Cancelled
        ji.Timeout = values.Timeout
        ji.Elapsed = values.Elapsed
        ji.State = values.State
        if values.Error != "" </span><span class="cov1" title="1">{
                ji.Err = errors.New(values.Error)
        }</span>
        <span class="cov1" title="1">ji.Output = new(bufferutil.Buffer)
        if err := json.Unmarshal([]byte(values.Output), ji.Output); err != nil </span><span class="cov0" title="0">{
                return ex.New(err)
        }</span>
        <span class="cov1" title="1">handlers := new(bufferutil.BufferHandlers)
        ji.Output.Handler = handlers.Handle
        ji.OutputHandlers = handlers
        return nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cron

// NOTE: ALL TIMES ARE IN UTC. JUST USE UTC.

import (
        "context"
        "fmt"
        "sort"
        "sync"
        "time"

        "github.com/blend/go-sdk/async"
        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/logger"
)

// New returns a new job manager.
func New(options ...JobManagerOption) *JobManager <span class="cov9" title="19">{
        jm := JobManager{
                Latch: async.NewLatch(),
                Jobs:  map[string]*JobScheduler{},
        }
        for _, option := range options </span><span class="cov2" title="2">{
                option(&amp;jm)
        }</span>
        <span class="cov9" title="19">return &amp;jm</span>
}

// JobManager is the main orchestration and job management object.
type JobManager struct {
        sync.Mutex
        Latch   *async.Latch
        Tracer  Tracer
        Log     logger.Log
        Started time.Time
        Paused  time.Time
        Stopped time.Time
        Jobs    map[string]*JobScheduler
}

// --------------------------------------------------------------------------------
// Core Methods
// --------------------------------------------------------------------------------

// LoadJobs loads a variadic list of jobs.
func (jm *JobManager) LoadJobs(jobs ...Job) error <span class="cov9" title="23">{
        jm.Lock()
        defer jm.Unlock()

        for _, job := range jobs </span><span class="cov10" title="24">{
                jobName := job.Name()
                if _, hasJob := jm.Jobs[jobName]; hasJob </span><span class="cov1" title="1">{
                        return ex.New(ErrJobAlreadyLoaded, ex.OptMessagef("job: %s", job.Name()))
                }</span>

                <span class="cov9" title="23">scheduler := NewJobScheduler(job,
                        OptJobSchedulerTracer(jm.Tracer),
                        OptJobSchedulerLog(jm.Log),
                )

                if err := scheduler.RestoreHistory(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logger.MaybeError(jm.Log, err)
                        continue</span>
                }
                <span class="cov9" title="23">jm.Jobs[jobName] = scheduler</span>
        }
        <span class="cov9" title="22">return nil</span>
}

// DisableJobs disables a variadic list of job names.
func (jm *JobManager) DisableJobs(jobNames ...string) error <span class="cov4" title="3">{
        jm.Lock()
        defer jm.Unlock()

        for _, jobName := range jobNames </span><span class="cov4" title="3">{
                if job, ok := jm.Jobs[jobName]; ok </span><span class="cov4" title="3">{
                        job.Disable()
                }</span> else<span class="cov0" title="0"> {
                        return ex.New(ErrJobNotFound, ex.OptMessagef("job: %s", jobName))
                }</span>
        }
        <span class="cov4" title="3">return nil</span>
}

// EnableJobs enables a variadic list of job names.
func (jm *JobManager) EnableJobs(jobNames ...string) error <span class="cov2" title="2">{
        jm.Lock()
        defer jm.Unlock()

        for _, jobName := range jobNames </span><span class="cov2" title="2">{
                if job, ok := jm.Jobs[jobName]; ok </span><span class="cov2" title="2">{
                        job.Enable()
                }</span> else<span class="cov0" title="0"> {
                        return ex.New(ErrJobNotFound, ex.OptMessagef("job: %s", jobName))
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// HasJob returns if a jobName is loaded or not.
func (jm *JobManager) HasJob(jobName string) (hasJob bool) <span class="cov1" title="1">{
        jm.Lock()
        defer jm.Unlock()
        _, hasJob = jm.Jobs[jobName]
        return
}</span>

// Job returns a job metadata by name.
func (jm *JobManager) Job(jobName string) (job *JobScheduler, err error) <span class="cov7" title="9">{
        jm.Lock()
        defer jm.Unlock()

        if jobScheduler, hasJob := jm.Jobs[jobName]; hasJob </span><span class="cov6" title="8">{
                job = jobScheduler
        }</span> else<span class="cov1" title="1"> {
                err = ex.New(ErrJobNotLoaded, ex.OptMessagef("job: %s", jobName))
        }</span>
        <span class="cov7" title="9">return</span>
}

// IsJobDisabled returns if a job is disabled.
func (jm *JobManager) IsJobDisabled(jobName string) (value bool) <span class="cov5" title="5">{
        jm.Lock()
        defer jm.Unlock()

        if job, hasJob := jm.Jobs[jobName]; hasJob </span><span class="cov5" title="5">{
                value = job.Disabled
                if job.DisabledProvider != nil </span><span class="cov5" title="5">{
                        value = value || job.DisabledProvider()
                }</span>
        }
        <span class="cov5" title="5">return</span>
}

// IsJobRunning returns if a job is currently running.
func (jm *JobManager) IsJobRunning(jobName string) (isRunning bool) <span class="cov4" title="3">{
        jm.Lock()
        defer jm.Unlock()

        if job, ok := jm.Jobs[jobName]; ok </span><span class="cov2" title="2">{
                isRunning = !job.Idle()
        }</span>
        <span class="cov4" title="3">return</span>
}

// RunJobs runs a variadic list of job names.
func (jm *JobManager) RunJobs(jobNames ...string) error <span class="cov1" title="1">{
        jm.Lock()
        defer jm.Unlock()

        for _, jobName := range jobNames </span><span class="cov2" title="2">{
                if job, ok := jm.Jobs[jobName]; ok </span><span class="cov2" title="2">{
                        job.Run()
                }</span> else<span class="cov0" title="0"> {
                        return ex.New(ErrJobNotLoaded, ex.OptMessagef("job: %s", jobName))
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// RunJob runs a job by jobName on demand.
func (jm *JobManager) RunJob(jobName string) (*JobInvocation, error) <span class="cov7" title="10">{
        jm.Lock()
        defer jm.Unlock()

        job, ok := jm.Jobs[jobName]
        if !ok </span><span class="cov0" title="0">{
                return nil, ex.New(ErrJobNotLoaded, ex.OptMessagef("job: %s", jobName))
        }</span>
        <span class="cov7" title="10">return job.RunAsync()</span>
}

// CancelJob cancels (sends the cancellation signal) to a running job.
func (jm *JobManager) CancelJob(jobName string) (err error) <span class="cov1" title="1">{
        jm.Lock()
        defer jm.Unlock()

        jobScheduler, ok := jm.Jobs[jobName]
        if !ok </span><span class="cov0" title="0">{
                err = ex.New(ErrJobNotFound, ex.OptMessagef("job: %s", jobName))
                return
        }</span>
        <span class="cov1" title="1">jobScheduler.Cancel()
        return</span>
}

// State returns the job manager state.
func (jm *JobManager) State() JobManagerState <span class="cov6" title="6">{
        if jm.Latch.IsStarted() </span><span class="cov4" title="3">{
                if !jm.Paused.IsZero() </span><span class="cov1" title="1">{
                        return JobManagerStatePaused
                }</span>
                <span class="cov2" title="2">return JobManagerStateRunning</span>
        } else<span class="cov4" title="3"> if jm.Latch.IsStopped() </span><span class="cov4" title="3">{
                return JobManagerStateStopped
        }</span>
        <span class="cov0" title="0">return JobManagerStateUnknown</span>
}

// Status returns a status object.
func (jm *JobManager) Status() JobManagerStatus <span class="cov4" title="3">{
        jm.Lock()
        defer jm.Unlock()

        status := JobManagerStatus{
                State:   jm.State(),
                Started: jm.Started,
                Stopped: jm.Stopped,
                Running: map[string]JobInvocation{},
        }
        for _, job := range jm.Jobs </span><span class="cov5" title="5">{
                status.Jobs = append(status.Jobs, job.Status())
                if job.Last != nil </span><span class="cov0" title="0">{
                        if job.Last.Started.After(status.JobLastStarted) </span><span class="cov0" title="0">{
                                status.JobLastStarted = job.Last.Started
                        }</span>
                }
                <span class="cov5" title="5">if job.Current != nil </span><span class="cov2" title="2">{
                        status.Running[job.Name()] = *job.Current
                }</span>
        }
        <span class="cov4" title="3">sort.Sort(JobSchedulerStatusesByJobNameAsc(status.Jobs))
        return status</span>
}

//
// Life Cycle
//

// Start starts the job manager and blocks.
func (jm *JobManager) Start() error <span class="cov0" title="0">{
        stopped := jm.Latch.NotifyStopped()
        if err := jm.StartAsync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">&lt;-stopped
        return nil</span>
}

// StartAsync starts the job manager and the loaded jobs.
// It does not block.
func (jm *JobManager) StartAsync() error <span class="cov4" title="4">{
        if !jm.Latch.CanStart() </span><span class="cov0" title="0">{
                return async.ErrCannotStart
        }</span>
        <span class="cov4" title="4">jm.Latch.Starting()
        logger.MaybeInfo(jm.Log, "job manager starting")
        for _, job := range jm.Jobs </span><span class="cov2" title="2">{
                job.Log = jm.Log
                job.Tracer = jm.Tracer
                go job.Start()
                &lt;-job.NotifyStarted()
        }</span>
        <span class="cov4" title="4">jm.Latch.Started()
        jm.Started = time.Now().UTC()
        logger.MaybeInfo(jm.Log, "job manager started")
        return nil</span>
}

// Pause stops the job manager's job schedulers but does not
// shut down the job manager.
func (jm *JobManager) Pause() error <span class="cov1" title="1">{
        jm.Lock()
        defer jm.Unlock()

        if !jm.Paused.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot pause; already paused")
        }</span>
        <span class="cov1" title="1">jm.Paused = time.Now().UTC()
        logger.MaybeInfo(jm.Log, "job manager pausing")
        for _, job := range jm.Jobs </span><span class="cov1" title="1">{
                job.Stop()
        }</span>

        <span class="cov1" title="1">logger.MaybeInfo(jm.Log, "job manager paused")
        return nil</span>
}

// Resume restarts the job manager's job schedulers.
// This call is asynchronous and does not block.
func (jm *JobManager) Resume() error <span class="cov1" title="1">{
        jm.Lock()
        defer jm.Unlock()

        if jm.Paused.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot resume; not paused")
        }</span>
        <span class="cov1" title="1">jm.Paused = time.Time{}
        logger.MaybeInfo(jm.Log, "job manager pausing")
        for _, job := range jm.Jobs </span><span class="cov1" title="1">{
                go func() </span><span class="cov1" title="1">{
                        if err := job.Start(); err != nil </span><span class="cov0" title="0">{
                                logger.MaybeError(jm.Log, err)
                        }</span>
                }()
                <span class="cov1" title="1">&lt;-job.NotifyStarted()</span>
        }
        <span class="cov1" title="1">logger.MaybeInfo(jm.Log, "job manager resumed")
        return nil</span>
}

// Stop stops the schedule runner for a JobManager.
func (jm *JobManager) Stop() error <span class="cov4" title="4">{
        if !jm.Latch.CanStop() </span><span class="cov1" title="1">{
                return async.ErrCannotStop
        }</span>
        <span class="cov4" title="3">jm.Latch.Stopping()
        logger.MaybeInfo(jm.Log, "job manager shutting down")
        for _, job := range jm.Jobs </span><span class="cov5" title="5">{
                job.Stop()
        }</span>
        <span class="cov4" title="3">jm.Latch.Stopped()
        jm.Stopped = time.Now().UTC()
        logger.MaybeInfo(jm.Log, "job manager shutdown complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cron

import "github.com/blend/go-sdk/logger"

// JobManagerOption is a job manager option.
type JobManagerOption func(*JobManager)

// OptLog sets the job manager logger.
func OptLog(log logger.Log) JobManagerOption <span class="cov8" title="1">{
        return func(jm *JobManager) </span><span class="cov8" title="1">{ jm.Log = log }</span>
}

// OptTracer sets the job manager tracer.
func OptTracer(tracer Tracer) JobManagerOption <span class="cov8" title="1">{
        return func(jm *JobManager) </span><span class="cov8" title="1">{ jm.Tracer = tracer }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cron

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/blend/go-sdk/stringutil"

        "github.com/blend/go-sdk/async"
        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/mathutil"
)

// NewJobScheduler returns a job scheduler for a given job.
func NewJobScheduler(job Job, options ...JobSchedulerOption) *JobScheduler <span class="cov8" title="30">{
        js := &amp;JobScheduler{
                Latch: async.NewLatch(),
                Job:   job,
        }

        if typed, ok := job.(JobConfigProvider); ok </span><span class="cov0" title="0">{
                js.Config = typed.JobConfig()
        }</span>

        <span class="cov8" title="30">if typed, ok := job.(ScheduleProvider); ok </span><span class="cov8" title="29">{
                js.Schedule = typed.Schedule()
        }</span>

        <span class="cov8" title="30">if typed, ok := job.(DescriptionProvider); ok </span><span class="cov0" title="0">{
                js.DescriptionProvider = typed.Description
        }</span> else<span class="cov8" title="30"> {
                js.DescriptionProvider = func() string </span><span class="cov0" title="0">{ return js.Config.Description }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(LabelsProvider); ok </span><span class="cov8" title="23">{
                js.LabelsProvider = typed.Labels
        }</span> else<span class="cov5" title="7"> {
                js.LabelsProvider = func() map[string]string </span><span class="cov0" title="0">{ return js.Config.Labels }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(TimeoutProvider); ok </span><span class="cov8" title="24">{
                js.TimeoutProvider = typed.Timeout
        }</span> else<span class="cov5" title="6"> {
                js.TimeoutProvider = func() time.Duration </span><span class="cov4" title="5">{ return js.Config.TimeoutOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(ShutdownGracePeriodProvider); ok </span><span class="cov8" title="23">{
                js.ShutdownGracePeriodProvider = typed.ShutdownGracePeriod
        }</span> else<span class="cov5" title="7"> {
                js.ShutdownGracePeriodProvider = func() time.Duration </span><span class="cov0" title="0">{ return js.Config.ShutdownGracePeriodOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(DisabledProvider); ok </span><span class="cov8" title="24">{
                js.DisabledProvider = typed.Disabled
        }</span> else<span class="cov5" title="6"> {
                js.DisabledProvider = func() bool </span><span class="cov2" title="2">{ return js.Config.DisabledOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(HistoryDisabledProvider); ok </span><span class="cov8" title="23">{
                js.HistoryDisabledProvider = typed.HistoryDisabled
        }</span> else<span class="cov5" title="7"> {
                js.HistoryDisabledProvider = func() bool </span><span class="cov4" title="4">{ return js.Config.HistoryDisabledOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(HistoryPersistenceDisabledProvider); ok </span><span class="cov8" title="23">{
                js.HistoryPersistenceDisabledProvider = typed.HistoryPersistenceDisabled
        }</span> else<span class="cov5" title="7"> {
                js.HistoryPersistenceDisabledProvider = func() bool </span><span class="cov6" title="11">{ return js.Config.HistoryPersistenceDisabledOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(HistoryMaxCountProvider); ok </span><span class="cov8" title="23">{
                js.HistoryMaxCountProvider = typed.HistoryMaxCount
        }</span> else<span class="cov5" title="7"> {
                js.HistoryMaxCountProvider = func() int </span><span class="cov4" title="4">{ return js.Config.HistoryMaxCountOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(HistoryMaxAgeProvider); ok </span><span class="cov8" title="23">{
                js.HistoryMaxAgeProvider = typed.HistoryMaxAge
        }</span> else<span class="cov5" title="7"> {
                js.HistoryMaxAgeProvider = func() time.Duration </span><span class="cov4" title="4">{ return js.Config.HistoryMaxAgeOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(ShouldSkipLoggerListenersProvider); ok </span><span class="cov8" title="23">{
                js.ShouldSkipLoggerListenersProvider = typed.ShouldSkipLoggerListeners
        }</span> else<span class="cov5" title="7"> {
                js.ShouldSkipLoggerListenersProvider = func() bool </span><span class="cov1" title="1">{ return js.Config.ShouldSkipLoggerListenersOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(ShouldSkipLoggerOutputProvider); ok </span><span class="cov8" title="23">{
                js.ShouldSkipLoggerOutputProvider = typed.ShouldSkipLoggerOutput
        }</span> else<span class="cov5" title="7"> {
                js.ShouldSkipLoggerOutputProvider = func() bool </span><span class="cov2" title="2">{ return js.Config.ShouldSkipLoggerOutputOrDefault() }</span>
        }

        <span class="cov8" title="30">if typed, ok := job.(HistoryProvider); ok </span><span class="cov8" title="23">{
                js.HistoryPersistProvider = typed.PersistHistory
                js.HistoryRestoreProvider = typed.RestoreHistory
        }</span>

        <span class="cov8" title="30">for _, option := range options </span><span class="cov10" title="46">{
                option(js)
        }</span>

        <span class="cov8" title="30">return js</span>
}

// JobScheduler is a job instance.
type JobScheduler struct {
        sync.Mutex
        Latch *async.Latch

        Job    Job
        Config JobConfig
        Tracer Tracer
        Log    logger.Log

        Schedule    Schedule
        Disabled    bool
        NextRuntime time.Time
        Current     *JobInvocation
        Last        *JobInvocation
        History     []JobInvocation

        DescriptionProvider                func() string
        LabelsProvider                     func() map[string]string
        DisabledProvider                   func() bool
        TimeoutProvider                    func() time.Duration
        ShutdownGracePeriodProvider        func() time.Duration
        ShouldSkipLoggerListenersProvider  func() bool
        ShouldSkipLoggerOutputProvider     func() bool
        HistoryDisabledProvider            func() bool
        HistoryPersistenceDisabledProvider func() bool
        HistoryMaxCountProvider            func() int
        HistoryMaxAgeProvider              func() time.Duration

        HistoryRestoreProvider func(context.Context) ([]JobInvocation, error)
        HistoryPersistProvider func(context.Context, []JobInvocation) error
}

// Name returns the job name.
func (js *JobScheduler) Name() string <span class="cov9" title="34">{
        return js.Job.Name()
}</span>

// Description returns the description.
func (js *JobScheduler) Description() string <span class="cov0" title="0">{
        return js.DescriptionProvider()
}</span>

// Labels returns the job labels, including
// automatically added ones like `name`.
func (js *JobScheduler) Labels() map[string]string <span class="cov5" title="7">{
        output := map[string]string{
                "name":   stringutil.Slugify(js.Name()),
                "state":  string(js.State()),
                "active": fmt.Sprintf("%v", !js.Idle()),
        }
        if js.Last != nil </span><span class="cov2" title="2">{
                output["last"] = stringutil.Slugify(string(js.Last.State))
        }</span>
        <span class="cov5" title="7">if js.LabelsProvider != nil </span><span class="cov5" title="7">{
                for key, value := range js.LabelsProvider() </span><span class="cov3" title="3">{
                        output[key] = stringutil.Slugify(value)
                }</span>
        }
        <span class="cov5" title="7">return output</span>
}

// State returns the job scheduler state.
func (js *JobScheduler) State() JobSchedulerState <span class="cov6" title="12">{
        if js.Latch.IsStarted() </span><span class="cov0" title="0">{
                return JobSchedulerStateRunning
        }</span>
        <span class="cov6" title="12">if js.Latch.IsStopped() </span><span class="cov6" title="12">{
                return JobSchedulerStateStopped
        }</span>
        <span class="cov0" title="0">return JobSchedulerStateUnknown</span>
}

// Status returns the job scheduler status.
func (js *JobScheduler) Status() JobSchedulerStatus <span class="cov4" title="5">{
        status := JobSchedulerStatus{
                Name:                       js.Name(),
                State:                      js.State(),
                Labels:                     js.Labels(),
                Disabled:                   !js.Enabled(),
                NextRuntime:                js.NextRuntime,
                Timeout:                    js.TimeoutProvider(),
                Current:                    js.Current,
                Last:                       js.Last,
                Stats:                      js.Stats(),
                HistoryDisabled:            js.HistoryDisabledProvider(),
                HistoryPersistenceDisabled: js.HistoryPersistenceDisabledProvider(),
                HistoryMaxCount:            js.HistoryMaxCountProvider(),
                HistoryMaxAge:              js.HistoryMaxAgeProvider(),
        }
        if typed, ok := js.Schedule.(fmt.Stringer); ok </span><span class="cov0" title="0">{
                status.Schedule = typed.String()
        }</span>
        <span class="cov4" title="5">return status</span>
}

// Stats returns job stats.
func (js *JobScheduler) Stats() JobSchedulerStats <span class="cov5" title="6">{
        output := JobSchedulerStats{
                RunsTotal: len(js.History),
        }
        var elapsedTimes []time.Duration

        for _, ji := range js.History </span><span class="cov5" title="8">{
                switch ji.State </span>{
                case JobInvocationStateComplete:<span class="cov4" title="4">
                        output.RunsSuccessful++</span>
                case JobInvocationStateFailed:<span class="cov2" title="2">
                        output.RunsFailed++</span>
                case JobInvocationStateCancelled:<span class="cov2" title="2">
                        if !ji.Timeout.IsZero() </span><span class="cov1" title="1">{
                                output.RunsTimedOut++
                        }</span> else<span class="cov1" title="1"> {
                                output.RunsCancelled++
                        }</span>
                }

                <span class="cov5" title="8">elapsedTimes = append(elapsedTimes, ji.Elapsed)
                if ji.Elapsed &gt; output.ElapsedMax </span><span class="cov5" title="8">{
                        output.ElapsedMax = ji.Elapsed
                }</span>

                <span class="cov5" title="8">if ji.Output != nil </span><span class="cov0" title="0">{
                        output.OutputBytes += len(ji.Output.Bytes())
                }</span>
        }
        <span class="cov5" title="6">if output.RunsTotal &gt; 0 </span><span class="cov1" title="1">{
                output.SuccessRate = float64(output.RunsSuccessful) / float64(output.RunsTotal)
        }</span>
        <span class="cov5" title="6">output.Elapsed50th = mathutil.PercentileOfDuration(elapsedTimes, 50.0)
        output.Elapsed95th = mathutil.PercentileOfDuration(elapsedTimes, 95.0)
        return output</span>
}

// Start starts the scheduler.
// This call blocks.
func (js *JobScheduler) Start() error <span class="cov3" title="3">{
        if !js.Latch.CanStart() </span><span class="cov0" title="0">{
                return fmt.Errorf("already started")
        }</span>
        <span class="cov3" title="3">js.infof("scheduler starting")
        js.Latch.Starting()
        js.infof("scheduler started")
        js.RunLoop()
        js.infof("scheduler exiting")
        return nil</span>
}

// Stop stops the scheduler.
func (js *JobScheduler) Stop() error <span class="cov5" title="6">{
        if !js.Latch.CanStop() </span><span class="cov4" title="5">{
                return fmt.Errorf("already stopped")
        }</span>
        <span class="cov1" title="1">stopped := js.Latch.NotifyStopped()

        js.infof("scheduler stopping")
        // signal we are stopping.
        js.Latch.Stopping()

        ctx, cancel := js.createContextWithTimeout(js.ShutdownGracePeriodProvider())
        defer cancel()
        js.cancelJobInvocation(ctx, js.Current)
        js.PersistHistory(ctx)

        &lt;-stopped
        js.infof("scheduler stopped")
        return nil</span>
}

// NotifyStarted notifies the job scheduler has started.
func (js *JobScheduler) NotifyStarted() &lt;-chan struct{} <span class="cov3" title="3">{
        return js.Latch.NotifyStarted()
}</span>

// NotifyStopped notifies the job scheduler has stopped.
func (js *JobScheduler) NotifyStopped() &lt;-chan struct{} <span class="cov0" title="0">{
        return js.Latch.NotifyStopped()
}</span>

// Enable sets the job as enabled.
func (js *JobScheduler) Enable() <span class="cov3" title="3">{
        js.Disabled = false
        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov0" title="0">{
                event := NewEvent(FlagEnabled, js.Name())
                js.Log.Trigger(js.logEventContext(context.Background()), event)
        }</span>
        <span class="cov3" title="3">if typed, ok := js.Job.(OnEnabledReceiver); ok </span><span class="cov2" title="2">{
                typed.OnEnabled(context.Background())
        }</span>
}

// Disable sets the job as disabled.
func (js *JobScheduler) Disable() <span class="cov4" title="4">{
        js.Disabled = true
        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov0" title="0">{
                event := NewEvent(FlagDisabled, js.Name())
                js.Log.Trigger(js.logEventContext(context.Background()), event)
        }</span>
        <span class="cov4" title="4">if typed, ok := js.Job.(OnDisabledReceiver); ok </span><span class="cov2" title="2">{
                typed.OnDisabled(context.Background())
        }</span>
}

// Cancel stops all running invocations.
func (js *JobScheduler) Cancel() error <span class="cov1" title="1">{
        if js.Current == nil </span><span class="cov0" title="0">{
                js.debugf("job cancellation; not running")
                return nil
        }</span>
        <span class="cov1" title="1">gracePeriod := js.ShutdownGracePeriodProvider()
        if gracePeriod &gt; 0 </span><span class="cov0" title="0">{
                js.debugf("job cancellation; cancelling with %v grace period", gracePeriod)
                ctx, cancel := js.createContextWithTimeout(js.ShutdownGracePeriodProvider())
                defer cancel()

                js.cancelJobInvocation(ctx, js.Current)
        }</span>
        <span class="cov1" title="1">js.debugf("job cancellation; cancelling immediately")
        js.Current.Cancel()
        return nil</span>
}

// RunLoop is the main scheduler loop.
// it alarms on the next runtime and forks a new routine to run the job.
// It can be aborted with the scheduler's async.Latch.
func (js *JobScheduler) RunLoop() <span class="cov3" title="3">{
        js.Latch.Started()
        defer func() </span><span class="cov2" title="2">{
                js.Latch.Stopped()
        }</span>()

        <span class="cov3" title="3">if js.Schedule != nil </span><span class="cov3" title="3">{
                js.NextRuntime = js.Schedule.Next(js.NextRuntime)
        }</span>
        // if the schedule returns a zero timestamp
        // it should be interpretted as *not* to automatically
        // schedule the job to be run.
        <span class="cov3" title="3">if js.NextRuntime.IsZero() </span><span class="cov0" title="0">{
                return
        }</span>

        // this references the underlying js.Latch
        // it returns the current latch signal for stopping *before*
        // the job kicks off.
        <span class="cov3" title="3">notifyStopping := js.Latch.NotifyStopping()

        for </span><span class="cov4" title="4">{
                if js.NextRuntime.IsZero() </span><span class="cov1" title="1">{
                        return
                }</span>

                <span class="cov3" title="3">runAt := time.After(js.NextRuntime.UTC().Sub(Now()))
                select </span>{
                case &lt;-runAt:<span class="cov1" title="1">
                        // if the job is enabled
                        // and there isn't another instance running
                        if js.CanBeScheduled() </span><span class="cov1" title="1">{
                                // start the job invocation
                                go js.Run()
                        }</span>

                        // set up the next runtime.
                        <span class="cov1" title="1">js.NextRuntime = js.Schedule.Next(js.NextRuntime)</span>

                case &lt;-notifyStopping:<span class="cov1" title="1">
                        // note: we bail hard here
                        // because the job executions in flight are
                        // handled by the context cancellation.
                        return</span>
                }
        }
}

// RunAsync forces the job to run.
func (js *JobScheduler) RunAsync() (*JobInvocation, error) <span class="cov7" title="16">{
        // if there is already another instance running
        if !js.Idle() </span><span class="cov0" title="0">{
                return nil, ex.New(ErrJobAlreadyRunning, ex.OptMessagef("job: %s", js.Name()))
        }</span>

        <span class="cov7" title="16">timeout := js.TimeoutProvider()

        // create a job invocation, or a record of each
        // individual execution of a job.
        ji := NewJobInvocation(js.Name())
        ji.Context, ji.Cancel = js.createContextWithTimeout(timeout)

        if timeout &gt; 0 </span><span class="cov0" title="0">{
                ji.Timeout = ji.Started.Add(timeout)
        }</span>
        <span class="cov7" title="16">js.addCurrent(ji)

        var err error
        var tf TraceFinisher
        // load the job invocation into the context for the job invocation.
        // this will let us pull the job invocation off the context
        // within the job action.
        ji.Context = WithJobInvocation(ji.Context, ji)

        go func() </span><span class="cov7" title="16">{
                // this defer runs all cleanup actions
                // it recovers panics
                // it cancels the timeout (if relevant)
                // it rotates the current and last references
                // it fires lifecycle events
                defer func() </span><span class="cov7" title="16">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                err = ex.New(err)
                        }</span>
                        <span class="cov7" title="16">if ji.Cancel != nil </span><span class="cov7" title="16">{
                                ji.Cancel()
                        }</span>
                        <span class="cov7" title="16">if tf != nil </span><span class="cov1" title="1">{
                                tf.Finish(ji.Context)
                        }</span>

                        <span class="cov7" title="16">ji.Finished = Now()
                        ji.Elapsed = ji.Finished.Sub(ji.Started)
                        ji.Err = err

                        if err != nil &amp;&amp; IsJobCancelled(err) </span><span class="cov1" title="1">{
                                ji.Cancelled = ji.Finished
                                js.onCancelled(ji.Context, ji)
                        }</span> else<span class="cov7" title="15"> if ji.Err != nil </span><span class="cov3" title="3">{
                                js.onFailure(ji.Context, ji)
                        }</span> else<span class="cov6" title="12"> {
                                js.onComplete(ji.Context, ji)
                        }</span>

                        <span class="cov7" title="16">js.finishCurrent(ji)
                        js.PersistHistory(ji.Context)</span>
                }()

                // if the tracer is set, create a trace context
                <span class="cov7" title="16">if js.Tracer != nil </span><span class="cov1" title="1">{
                        ji.Context, tf = js.Tracer.Start(ji.Context)
                }</span>
                // fire the on start event
                <span class="cov7" title="16">js.onStart(ji.Context, ji)

                // check if the job has been canceled
                // or if it's finished.
                select </span>{
                case &lt;-ji.Context.Done():<span class="cov1" title="1">
                        err = ErrJobCancelled
                        return</span>
                case err = &lt;-js.safeBackgroundExec(ji.Context):<span class="cov7" title="15">
                        return</span>
                }
        }()
        <span class="cov7" title="16">return ji, nil</span>
}

// Run forces the job to run.
// This call will block.
// It checks if the job should be allowed to execute.
func (js *JobScheduler) Run() <span class="cov5" title="6">{
        ji, err := js.RunAsync()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="6">&lt;-ji.Done</span>
}

//
// exported utility methods
//

// JobInvocation returns an invocation by id.
func (js *JobScheduler) JobInvocation(id string) *JobInvocation <span class="cov1" title="1">{
        js.Lock()
        defer js.Unlock()

        if js.Current != nil &amp;&amp; js.Current.ID == id </span><span class="cov0" title="0">{
                return js.Current
        }</span>
        <span class="cov1" title="1">if js.Last != nil &amp;&amp; js.Last.ID == id </span><span class="cov0" title="0">{
                return js.Last
        }</span>
        <span class="cov1" title="1">for _, ji := range js.History </span><span class="cov4" title="4">{
                if ji.ID == id </span><span class="cov1" title="1">{
                        return &amp;ji
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RestoreHistory calls the persist handler if it's set.
func (js *JobScheduler) RestoreHistory(ctx context.Context) error <span class="cov8" title="25">{
        if js.HistoryPersistenceDisabledProvider() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="25">if js.HistoryRestoreProvider != nil </span><span class="cov7" title="18">{
                js.Lock()
                defer js.Unlock()
                var err error
                if js.History, err = js.HistoryRestoreProvider(ctx); err != nil </span><span class="cov0" title="0">{
                        return js.error(err)
                }</span>
                <span class="cov7" title="18">if len(js.History) &gt; 0 </span><span class="cov1" title="1">{
                        js.Last = &amp;js.History[len(js.History)-1]
                }</span>
        }
        <span class="cov8" title="25">return nil</span>
}

// PersistHistory calls the persist handler if it's set.
func (js *JobScheduler) PersistHistory(ctx context.Context) error <span class="cov7" title="19">{
        if js.HistoryPersistenceDisabledProvider() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="19">if js.HistoryPersistProvider != nil </span><span class="cov7" title="15">{
                js.Lock()
                defer js.Unlock()

                historyCopy := make([]JobInvocation, len(js.History))
                copy(historyCopy, js.History)
                if err := js.HistoryPersistProvider(ctx, historyCopy); err != nil </span><span class="cov1" title="1">{
                        return js.error(err)
                }</span>
        }
        <span class="cov7" title="18">return nil</span>
}

// CanBeScheduled returns if a job will be triggered automatically
// and isn't already in flight and set to be serial.
func (js *JobScheduler) CanBeScheduled() bool <span class="cov3" title="3">{
        return js.Enabled() &amp;&amp; js.Idle()
}</span>

// Enabled returns if the job is explicitly disabled,
// otherwise it checks if the job has an EnabledProvider
// returns the result of that.
// It returns true if there is no provider set.
func (js *JobScheduler) Enabled() bool <span class="cov5" title="8">{
        if js.Disabled </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="7">if js.DisabledProvider != nil </span><span class="cov5" title="7">{
                if js.DisabledProvider() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov5" title="7">return true</span>
}

// Idle returns if the job is not currently running.
func (js *JobScheduler) Idle() (isIdle bool) <span class="cov8" title="27">{
        js.Lock()
        isIdle = js.Current == nil
        js.Unlock()
        return
}</span>

//
// utility functions
//

func (js *JobScheduler) finishCurrent(ji *JobInvocation) <span class="cov7" title="16">{
        js.Lock()
        defer js.Unlock()

        if !js.HistoryDisabledProvider() </span><span class="cov7" title="15">{
                js.History = append(js.cullHistory(), *ji)
        }</span>
        <span class="cov7" title="16">js.Current = nil
        js.Last = ji
        close(ji.Done)</span>
}

func (js *JobScheduler) addCurrent(ji *JobInvocation) <span class="cov7" title="16">{
        js.Lock()
        js.Current = ji
        js.Unlock()
}</span>

func (js *JobScheduler) cullHistory() []JobInvocation <span class="cov7" title="17">{
        count := len(js.History)
        maxCount := js.HistoryMaxCountProvider()
        maxAge := js.HistoryMaxAgeProvider()

        now := time.Now().UTC()
        var filtered []JobInvocation
        for index, h := range js.History </span><span class="cov8" title="24">{
                if maxCount &gt; 0 </span><span class="cov8" title="20">{
                        if index &lt; (count - maxCount) </span><span class="cov4" title="5">{
                                continue</span>
                        }
                }
                <span class="cov7" title="19">if maxAge &gt; 0 </span><span class="cov7" title="15">{
                        if now.Sub(h.Started) &gt; maxAge </span><span class="cov4" title="5">{
                                continue</span>
                        }
                }
                <span class="cov7" title="14">filtered = append(filtered, h)</span>
        }
        <span class="cov7" title="17">return filtered</span>
}

func (js *JobScheduler) cancelJobInvocation(ctx context.Context, ji *JobInvocation) <span class="cov1" title="1">{
        deadlinePoll := time.Tick(500 * time.Millisecond)
        for </span><span class="cov1" title="1">{
                if ji == nil || ji.State != JobInvocationStateRunning </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">js.debugf("job cancellation; waiting for cancellation for invocation `%s`", ji.ID)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        ji.Cancel()
                        return</span>
                case &lt;-deadlinePoll:<span class="cov0" title="0"></span>
                }
        }
}

func (js *JobScheduler) safeBackgroundExec(ctx context.Context) chan error <span class="cov7" title="16">{
        errors := make(chan error)
        go func() </span><span class="cov7" title="16">{
                defer func() </span><span class="cov7" title="15">{
                        if r := recover(); r != nil </span><span class="cov1" title="1">{
                                errors &lt;- ex.New(r)
                        }</span>
                }()
                <span class="cov7" title="16">errors &lt;- js.Job.Execute(ctx)</span>
        }()
        <span class="cov7" title="16">return errors</span>
}

func (js *JobScheduler) createContextWithTimeout(timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov7" title="17">{
        if timeout &gt; 0 </span><span class="cov0" title="0">{
                return context.WithTimeout(context.Background(), timeout)
        }</span>
        <span class="cov7" title="17">return context.WithCancel(context.Background())</span>
}

func (js *JobScheduler) onStart(ctx context.Context, ji *JobInvocation) <span class="cov7" title="16">{
        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov1" title="1">{
                js.logTrigger(js.logEventContext(ctx), NewEvent(FlagStarted, ji.JobName, OptEventJobInvocation(ji.ID)))
        }</span>
        <span class="cov7" title="16">if typed, ok := js.Job.(OnStartReceiver); ok </span><span class="cov7" title="15">{
                typed.OnStart(ctx)
        }</span>
}

func (js *JobScheduler) onCancelled(ctx context.Context, ji *JobInvocation) <span class="cov1" title="1">{
        ji.State = JobInvocationStateCancelled

        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov0" title="0">{
                js.logTrigger(js.logEventContext(ctx), NewEvent(FlagCancelled, ji.JobName, OptEventJobInvocation(ji.ID), OptEventElapsed(ji.Elapsed)))
        }</span>
        <span class="cov1" title="1">if typed, ok := js.Job.(OnCancellationReceiver); ok </span><span class="cov1" title="1">{
                typed.OnCancellation(ctx)
        }</span>
}

func (js *JobScheduler) onComplete(ctx context.Context, ji *JobInvocation) <span class="cov6" title="12">{
        ji.State = JobInvocationStateComplete

        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov0" title="0">{
                js.logTrigger(js.logEventContext(ctx), NewEvent(FlagComplete, ji.JobName, OptEventJobInvocation(ji.ID), OptEventElapsed(ji.Elapsed)))
        }</span>
        <span class="cov6" title="12">if typed, ok := js.Job.(OnCompleteReceiver); ok </span><span class="cov6" title="11">{
                typed.OnComplete(ctx)
        }</span>

        <span class="cov6" title="12">if js.Last != nil &amp;&amp; js.Last.Err != nil </span><span class="cov1" title="1">{
                js.logTrigger(js.logEventContext(ctx), NewEvent(FlagFixed, ji.JobName, OptEventElapsed(ji.Elapsed)))
                if typed, ok := js.Job.(OnFixedReceiver); ok </span><span class="cov1" title="1">{
                        typed.OnFixed(ctx)
                }</span>
        }
}

func (js *JobScheduler) onFailure(ctx context.Context, ji *JobInvocation) <span class="cov3" title="3">{
        ji.State = JobInvocationStateFailed

        if js.Log != nil &amp;&amp; !js.ShouldSkipLoggerListenersProvider() </span><span class="cov1" title="1">{
                js.logTrigger(js.logEventContext(ctx), NewEvent(FlagFailed, ji.JobName, OptEventErr(ji.Err), OptEventJobInvocation(ji.ID), OptEventElapsed(ji.Elapsed)))
        }</span>
        <span class="cov3" title="3">if ji.Err != nil </span><span class="cov3" title="3">{
                js.error(ji.Err)
        }</span>
        <span class="cov3" title="3">if typed, ok := js.Job.(OnFailureReceiver); ok </span><span class="cov3" title="3">{
                typed.OnFailure(ctx)
        }</span>
        <span class="cov3" title="3">if js.Last != nil &amp;&amp; js.Last.Err == nil </span><span class="cov1" title="1">{
                if js.Log != nil </span><span class="cov0" title="0">{
                        js.logTrigger(js.logEventContext(ctx), NewEvent(FlagBroken, ji.JobName, OptEventJobInvocation(ji.ID), OptEventElapsed(ji.Elapsed)))
                }</span>
                <span class="cov1" title="1">if typed, ok := js.Job.(OnBrokenReceiver); ok </span><span class="cov1" title="1">{
                        typed.OnBroken(ctx)
                }</span>
        }
}

//
// logging helpers
//

func (js *JobScheduler) logEventContext(parent context.Context) context.Context <span class="cov3" title="3">{
        if js.ShouldSkipLoggerOutputProvider() </span><span class="cov0" title="0">{
                return logger.WithSkipWrite(parent)
        }</span>
        <span class="cov3" title="3">return parent</span>
}

func (js *JobScheduler) logTrigger(ctx context.Context, e logger.Event) <span class="cov3" title="3">{
        if js.Log == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">js.Log.WithPath(js.Name()).Trigger(ctx, e)</span>
}

func (js *JobScheduler) error(err error) error <span class="cov4" title="4">{
        if js.Log == nil </span><span class="cov3" title="3">{
                return err
        }</span>
        <span class="cov1" title="1">js.Log.WithPath(js.Name()).Error(err)
        return err</span>
}

func (js *JobScheduler) debugf(format string, args ...interface{}) <span class="cov1" title="1">{
        if js.Log == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov0" title="0">js.Log.WithPath(js.Name()).Debugf(format, args...)</span>
}

func (js *JobScheduler) infof(format string, args ...interface{}) <span class="cov6" title="10">{
        if js.Log == nil </span><span class="cov6" title="10">{
                return
        }</span>
        <span class="cov0" title="0">js.Log.WithPath(js.Name()).Infof(format, args...)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cron

import "github.com/blend/go-sdk/logger"

// JobSchedulerOption is an option for job schedulers.
type JobSchedulerOption func(*JobScheduler)

// OptJobSchedulerTracer sets the job scheduler tracer.
func OptJobSchedulerTracer(tracer Tracer) JobSchedulerOption <span class="cov10" title="23">{
        return func(js *JobScheduler) </span><span class="cov10" title="23">{ js.Tracer = tracer }</span>
}

// OptJobSchedulerLog sets the job scheduler logger.
func OptJobSchedulerLog(log logger.Log) JobSchedulerOption <span class="cov10" title="23">{
        return func(js *JobScheduler) </span><span class="cov10" title="23">{ js.Log = log }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cron

import (
        "fmt"
        "time"
)

var (
        _ Schedule     = (*OnTheHourAtUTCSchedule)(nil)
        _ fmt.Stringer = (*OnTheHourAtUTCSchedule)(nil)
)

// EveryHourOnTheHour returns a schedule that fires every 60 minutes on the 00th minute.
func EveryHourOnTheHour() Schedule <span class="cov0" title="0">{
        return OnTheHourAtUTCSchedule{}
}</span>

// EveryHourAtUTC returns a schedule that fires every hour at a given minute.
func EveryHourAtUTC(minute, second int) Schedule <span class="cov1" title="1">{
        return OnTheHourAtUTCSchedule{Minute: minute, Second: second}
}</span>

// OnTheHourAtUTCSchedule is a schedule that fires every hour on the given minute.
type OnTheHourAtUTCSchedule struct {
        Minute int
        Second int
}

// String returns a string representation of the schedule.
func (o OnTheHourAtUTCSchedule) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("on the hour at %v:%v", o.Minute, o.Second)
}</span>

// Next implements the chronometer Schedule api.
func (o OnTheHourAtUTCSchedule) Next(after time.Time) time.Time <span class="cov10" title="2">{
        var returnValue time.Time
        now := Now()
        if after.IsZero() </span><span class="cov1" title="1">{
                returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), o.Minute, o.Second, 0, time.UTC)
                if returnValue.Before(now) </span><span class="cov0" title="0">{
                        returnValue = returnValue.Add(time.Hour)
                }</span>
        } else<span class="cov1" title="1"> {
                returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), o.Minute, o.Second, 0, time.UTC)
                if returnValue.Before(after) </span><span class="cov1" title="1">{
                        returnValue = returnValue.Add(time.Hour)
                }</span>
        }
        <span class="cov10" title="2">return returnValue</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cron

import (
        "fmt"
        "time"
)

// Interface assertions.
var (
        _ Schedule     = (*OnceAtUTCSchedule)(nil)
        _ fmt.Stringer = (*OnceAtUTCSchedule)(nil)
)

// OnceAtUTC returns a schedule that fires once at a given time.
// It will never fire again unless reloaded.
func OnceAtUTC(t time.Time) Schedule <span class="cov1" title="1">{
        return OnceAtUTCSchedule{Time: t}
}</span>

// OnceAtUTCSchedule is a schedule.
type OnceAtUTCSchedule struct {
        Time time.Time
}

// String returns a string representation of the schedule.
func (oa OnceAtUTCSchedule) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("once at %s", oa.Time.Format(time.RFC3339))
}</span>

// Next returns the next runtime.
func (oa OnceAtUTCSchedule) Next(after time.Time) time.Time <span class="cov10" title="2">{
        if after.IsZero() </span><span class="cov0" title="0">{
                return oa.Time
        }</span>
        <span class="cov10" title="2">if oa.Time.After(after) </span><span class="cov1" title="1">{
                return oa.Time
        }</span>
        <span class="cov1" title="1">return Zero</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cron

// JobSchedulerStatusesByJobNameAsc is a wrapper that sorts job schedulers
// statuses by the job name ascending.
type JobSchedulerStatusesByJobNameAsc []JobSchedulerStatus

// Len implements sorter.
func (s JobSchedulerStatusesByJobNameAsc) Len() int <span class="cov10" title="3">{
        return len(s)
}</span>

// Swap implements sorter.
func (s JobSchedulerStatusesByJobNameAsc) Swap(i, j int) <span class="cov6" title="2">{
        s[i], s[j] = s[j], s[i]
}</span>

// Less implements sorter.
func (s JobSchedulerStatusesByJobNameAsc) Less(i, j int) bool <span class="cov10" title="3">{
        return s[i].Name &lt; s[j].Name
}</span>

// JobSchedulersByJobNameAsc is a wrapper that sorts job schedulers
// by the job name ascending.
type JobSchedulersByJobNameAsc []*JobScheduler

// Len implements sorter.
func (s JobSchedulersByJobNameAsc) Len() int <span class="cov0" title="0">{
        return len(s)
}</span>

// Swap implements sorter.
func (s JobSchedulersByJobNameAsc) Swap(i, j int) <span class="cov0" title="0">{
        s[i], s[j] = s[j], s[i]
}</span>

// Less implements sorter.
func (s JobSchedulersByJobNameAsc) Less(i, j int) bool <span class="cov0" title="0">{
        return s[i].Name() &lt; s[j].Name()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package cron

import (
        "fmt"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/stringutil"
)

// ParseString parses a cron formatted string into a schedule.
// The string must be at least 5 components, whitespace separated.
// If the string has 5 components a 0 will be prepended for the seconds component, and a * appended for the year component.
// If the string has 6 components a * appended for the year component.
// (seconds) (minutes) (hours) (day of month) (month) (day of week) (year)
/*
        Field name     Mandatory?   Allowed values    Allowed special characters
        ----------     ----------   --------------    --------------------------
        Seconds        No           0-59              * / , -
        Minutes        Yes          0-59              * / , -
        Hours          Yes          0-23              * / , -
        Day of month   Yes          1-31              * / , - L W
        Month          Yes          1-12 or JAN-DEC   * / , -
        Day of week    Yes          0-6 or SUN-SAT    * / , - L #
        Year           No           19702099         * / , -
*/
/*
You can also use shorthands for the cron string:
        @yearly is equivalent to "0 0 0 1 1 * *"
        @monthly is equivalent to "0 0 0 1 * * *"
        @weekly is equivalent to "0 0 0 * * 0 *"
        @daily is equivalent to "0 0 0 * * * *"
        @hourly is equivalent to "0 0 * * * * *"
        @every xyz will parse the `xyz` value as a duration and return an every schedule for that
*/
func ParseString(cronString string) (Schedule, error) <span class="cov2" title="18">{
        // escape shorthands.
        if shorthand, ok := StringScheduleShorthands[strings.TrimSpace(cronString)]; ok </span><span class="cov1" title="2">{
                cronString = shorthand
        }</span>

        <span class="cov2" title="18">if strings.HasPrefix(cronString, "@every") </span><span class="cov1" title="2">{
                duration, err := time.ParseDuration(strings.TrimSpace(strings.TrimPrefix(cronString, "@every")))
                if err != nil </span><span class="cov1" title="1">{
                        return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err))
                }</span>
                <span class="cov1" title="1">return Every(duration), nil</span>
        }

        <span class="cov2" title="16">parts := stringutil.SplitSpace(cronString)
        if len(parts) &lt; 5 || len(parts) &gt; 7 </span><span class="cov1" title="2">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(ErrStringScheduleComponents), ex.OptMessagef("provided string; %s", cronString))
        }</span>
        // fill in optional components
        <span class="cov2" title="14">if len(parts) == 5 </span><span class="cov1" title="1">{
                parts = append([]string{"0"}, parts...)
                parts = append(parts, "*")
        }</span> else<span class="cov2" title="13"> if len(parts) == 6 </span><span class="cov1" title="1">{
                parts = append(parts, "*")
        }</span>

        <span class="cov2" title="14">seconds, err := parsePart(parts[0], parseInt, below(60))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("seconds invalid"))
        }</span>

        <span class="cov2" title="14">minutes, err := parsePart(parts[1], parseInt, below(60))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("minutes invalid"))
        }</span>

        <span class="cov2" title="14">hours, err := parsePart(parts[2], parseInt, below(24))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("hours invalid"))
        }</span>

        <span class="cov2" title="14">days, err := parsePart(parts[3], parseInt, between(1, 32))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("days invalid"))
        }</span>

        <span class="cov2" title="14">months, err := parsePart(parts[4], parseMonth, between(1, 13))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("months invalid"))
        }</span>

        <span class="cov2" title="14">daysOfWeek, err := parsePart(parts[5], parseDayOfWeek, between(0, 7))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("days of week invalid"))
        }</span>

        <span class="cov2" title="14">years, err := parsePart(parts[6], parseInt, between(1970, 2100))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalid, ex.OptInner(err), ex.OptMessage("years invalid"))
        }</span>

        <span class="cov2" title="14">schedule := &amp;StringSchedule{
                Original:    cronString,
                Seconds:     seconds,
                Minutes:     minutes,
                Hours:       hours,
                DaysOfMonth: days,
                Months:      months,
                DaysOfWeek:  daysOfWeek,
                Years:       years,
        }
        return schedule, nil</span>
}

// Error Constants
const (
        ErrStringScheduleInvalid         ex.Class = "cron: schedule string invalid"
        ErrStringScheduleComponents      ex.Class = "cron: must have at least (5) components space delimited; ex: '0 0 * * * * *'"
        ErrStringScheduleValueOutOfRange ex.Class = "cron: string schedule part out of range"
        ErrStringScheduleInvalidRange    ex.Class = "cron: range (from-to) invalid"
)

// String schedule shorthands labels
const (
        StringScheduleShorthandAnnually = "@annually"
        StringScheduleShorthandYearly   = "@yearly"
        StringScheduleShorthandMonthly  = "@monthly"
        StringScheduleShorthandWeekly   = "@weekly"
        StringScheduleShorthandDaily    = "@daily"
        StringScheduleShorthandHourly   = "@hourly"
)

// String schedule shorthand values
var (
        StringScheduleShorthands = map[string]string{
                StringScheduleShorthandAnnually: "0 0 0 1 1 * *",
                StringScheduleShorthandYearly:   "0 0 0 1 1 * *",
                StringScheduleShorthandMonthly:  "0 0 0 1 * * *",
                StringScheduleShorthandDaily:    "0 0 0 * * * *",
                StringScheduleShorthandHourly:   "0 0 * * * * *",
        }
)

// Interface assertions.
var (
        _ Schedule     = (*StringSchedule)(nil)
        _ fmt.Stringer = (*StringSchedule)(nil)
)

// StringSchedule is a schedule generated from a cron string.
type StringSchedule struct {
        Original string

        Seconds     []int
        Minutes     []int
        Hours       []int
        DaysOfMonth []int
        Months      []int
        DaysOfWeek  []int
        Years       []int
}

// String returns the original string schedule.
func (ss *StringSchedule) String() string <span class="cov2" title="13">{
        return ss.Original
}</span>

// FullString returns a fully formed string representation of the schedule's components.
// It shows fields as expanded.
func (ss *StringSchedule) FullString() string <span class="cov0" title="0">{
        fields := []string{
                csvOfInts(ss.Seconds, "*"),
                csvOfInts(ss.Minutes, "*"),
                csvOfInts(ss.Hours, "*"),
                csvOfInts(ss.DaysOfMonth, "*"),
                csvOfInts(ss.Months, "*"),
                csvOfInts(ss.DaysOfWeek, "*"),
                csvOfInts(ss.Years, "*"),
        }
        return strings.Join(fields, " ")
}</span>

// Next implements cron.Schedule.
func (ss *StringSchedule) Next(after time.Time) time.Time <span class="cov7" title="21613">{
        working := after
        if after.IsZero() </span><span class="cov0" title="0">{
                working = Now()
        }</span>
        <span class="cov7" title="21613">original := working

        if len(ss.Years) &gt; 0 </span><span class="cov0" title="0">{
                for _, year := range ss.Years </span><span class="cov0" title="0">{
                        if year &gt;= working.Year() </span><span class="cov0" title="0">{
                                working = advanceYearTo(working, year)
                                break</span>
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.Months) &gt; 0 </span><span class="cov0" title="0">{
                var didSet bool
                for _, month := range ss.Months </span><span class="cov0" title="0">{
                        if time.Month(month) == working.Month() &amp;&amp; working.After(original) </span><span class="cov0" title="0">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov0" title="0">if time.Month(month) &gt; working.Month() </span><span class="cov0" title="0">{
                                working = advanceMonthTo(working, time.Month(month))
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !didSet </span><span class="cov0" title="0">{
                        working = advanceYear(working)
                        for _, month := range ss.Months </span><span class="cov0" title="0">{
                                if time.Month(month) &gt;= working.Month() </span><span class="cov0" title="0">{
                                        working = advanceMonthTo(working, time.Month(month))
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.DaysOfMonth) &gt; 0 </span><span class="cov0" title="0">{
                var didSet bool
                for _, day := range ss.DaysOfMonth </span><span class="cov0" title="0">{
                        if day == working.Day() &amp;&amp; working.After(original) </span><span class="cov0" title="0">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov0" title="0">if day &gt; working.Day() </span><span class="cov0" title="0">{
                                working = advanceDayTo(working, day)
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !didSet </span><span class="cov0" title="0">{
                        working = advanceMonth(working)
                        for _, day := range ss.DaysOfMonth </span><span class="cov0" title="0">{
                                if day &gt;= working.Day() </span><span class="cov0" title="0">{
                                        working = advanceDayTo(working, day)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.DaysOfWeek) &gt; 0 </span><span class="cov2" title="5">{
                var didSet bool
                for _, dow := range ss.DaysOfWeek </span><span class="cov2" title="11">{
                        if dow == int(working.Weekday()) &amp;&amp; working.After(original) </span><span class="cov0" title="0">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov2" title="11">if dow &gt; int(working.Weekday()) </span><span class="cov1" title="2">{
                                working = advanceDayBy(working, (dow - int(working.Weekday())))
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov2" title="5">if !didSet </span><span class="cov1" title="3">{
                        working = advanceToNextSunday(working)
                        for _, dow := range ss.DaysOfWeek </span><span class="cov1" title="3">{
                                if dow &gt;= int(working.Weekday()) </span><span class="cov1" title="3">{
                                        working = advanceDayBy(working, (dow - int(working.Weekday())))
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.Hours) &gt; 0 </span><span class="cov2" title="7">{
                var didSet bool
                for _, hour := range ss.Hours </span><span class="cov2" title="7">{
                        if hour == working.Hour() &amp;&amp; working.After(original) </span><span class="cov1" title="2">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov2" title="5">if hour &gt; working.Hour() </span><span class="cov1" title="3">{
                                working = advanceHourTo(working, hour)
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov2" title="7">if !didSet </span><span class="cov1" title="2">{
                        working = advanceDay(working)
                        for _, hour := range ss.Hours </span><span class="cov1" title="2">{
                                if hour &gt;= working.Hour() </span><span class="cov1" title="2">{
                                        working = advanceHourTo(working, hour)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.Minutes) &gt; 0 </span><span class="cov2" title="11">{
                var didSet bool
                for _, minute := range ss.Minutes </span><span class="cov2" title="11">{
                        if minute == working.Minute() &amp;&amp; working.After(original) </span><span class="cov1" title="4">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov2" title="7">if minute &gt; working.Minute() </span><span class="cov1" title="3">{
                                working = advanceMinuteTo(working, minute)
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov2" title="11">if !didSet </span><span class="cov1" title="4">{
                        working = advanceHour(working)
                        for _, minute := range ss.Minutes </span><span class="cov1" title="4">{
                                if minute &gt;= working.Minute() </span><span class="cov1" title="4">{
                                        working = advanceMinuteTo(working, minute)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">if len(ss.Seconds) &gt; 0 </span><span class="cov7" title="21610">{
                var didSet bool
                for _, second := range ss.Seconds </span><span class="cov10" title="680065">{
                        if second == working.Second() &amp;&amp; working.After(original) </span><span class="cov2" title="8">{
                                didSet = true
                                break</span>
                        }
                        <span class="cov9" title="680057">if second &gt; working.Second() </span><span class="cov7" title="21242">{
                                working = advanceSecondTo(working, second)
                                didSet = true
                                break</span>
                        }
                }
                <span class="cov7" title="21610">if !didSet </span><span class="cov4" title="360">{
                        working = advanceMinute(working)
                        for _, second := range ss.Hours </span><span class="cov0" title="0">{
                                if second &gt;= working.Second() </span><span class="cov0" title="0">{
                                        working = advanceSecondTo(working, second)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21613">return working</span>
}

func parsePart(values string, parser func(string) (int, error), validator func(int) bool) ([]int, error) <span class="cov4" title="98">{
        if values == string(cronSpecialStar) </span><span class="cov3" title="64">{
                return nil, nil
        }</span>

        // check if we need to expand an "every" pattern
        <span class="cov3" title="34">if strings.HasPrefix(values, cronSpecialEvery) </span><span class="cov1" title="3">{
                return parseEvery(values, parseInt, validator)
        }</span>

        <span class="cov3" title="31">components := strings.Split(values, string(cronSpecialComma))

        output := map[int]bool{}
        var component string
        for x := 0; x &lt; len(components); x++ </span><span class="cov3" title="31">{
                component = components[x]
                if strings.Contains(component, string(cronSpecialDash)) </span><span class="cov1" title="3">{
                        rangeValues, err := parseRange(values, parser, validator)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov1" title="3">for _, value := range rangeValues </span><span class="cov2" title="14">{
                                output[value] = true
                        }</span>
                        <span class="cov1" title="3">continue</span>
                }

                <span class="cov3" title="28">part, err := parser(component)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, ex.New(err)
                }</span>
                <span class="cov3" title="28">if validator != nil &amp;&amp; !validator(part) </span><span class="cov0" title="0">{
                        return nil, ex.New(err)
                }</span>
                <span class="cov3" title="28">output[part] = true</span>
        }
        <span class="cov3" title="31">return mapKeysToArray(output), nil</span>
}

func parseEvery(values string, parser func(string) (int, error), validator func(int) bool) ([]int, error) <span class="cov1" title="3">{
        every, err := parser(strings.TrimPrefix(values, "*/"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(err)
        }</span>
        <span class="cov1" title="3">if validator != nil &amp;&amp; !validator(every) </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleValueOutOfRange)
        }</span>

        <span class="cov1" title="3">var output []int
        for x := 0; x &lt; 60; x = x + every </span><span class="cov4" title="132">{
                output = append(output, x)
        }</span>
        <span class="cov1" title="3">return output, nil</span>
}

func parseRange(values string, parser func(string) (int, error), validator func(int) bool) ([]int, error) <span class="cov1" title="3">{
        parts := strings.Split(values, string(cronSpecialDash))

        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalidRange, ex.OptMessagef("invalid range: %s", values))
        }</span>

        <span class="cov1" title="3">from, err := parser(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(err)
        }</span>
        <span class="cov1" title="3">to, err := parser(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, ex.New(err)
        }</span>

        <span class="cov1" title="3">if validator != nil &amp;&amp; !validator(from) </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleValueOutOfRange, ex.OptMessage("invalid range from"))
        }</span>
        <span class="cov1" title="3">if validator != nil &amp;&amp; !validator(to) </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleValueOutOfRange, ex.OptMessage("invalid range to"))
        }</span>

        <span class="cov1" title="3">if from &gt;= to </span><span class="cov0" title="0">{
                return nil, ex.New(ErrStringScheduleInvalidRange, ex.OptMessage("invalid range; from greater than to"))
        }</span>

        <span class="cov1" title="3">var output []int
        for x := from; x &lt;= to; x++ </span><span class="cov2" title="14">{
                output = append(output, x)
        }</span>
        <span class="cov1" title="3">return output, nil</span>
}

func parseInt(s string) (int, error) <span class="cov3" title="29">{
        return strconv.Atoi(s)
}</span>

func parseMonth(s string) (int, error) <span class="cov0" title="0">{
        if value, ok := validMonths[s]; ok </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        <span class="cov0" title="0">value, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ex.New(err, ex.OptMessage("month not a valid integer"))
        }</span>
        <span class="cov0" title="0">if value &lt; 1 || value &gt; 12 </span><span class="cov0" title="0">{
                return 0, ex.New(ErrStringScheduleValueOutOfRange, ex.OptMessagef("month out of range (1-12): %s", s))
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func parseDayOfWeek(s string) (int, error) <span class="cov2" title="8">{
        if value, ok := validDaysOfWeek[s]; ok </span><span class="cov1" title="4">{
                return value, nil
        }</span>
        <span class="cov1" title="4">value, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ex.New(err, ex.OptMessage("day of week not a valid integer"))
        }</span>
        <span class="cov1" title="4">if value &lt; 0 || value &gt; 6 </span><span class="cov0" title="0">{
                return 0, ex.New(ErrStringScheduleValueOutOfRange, ex.OptMessagef("day of week out of range (0-6): %s", s))
        }</span>
        <span class="cov1" title="4">return value, nil</span>
}

func below(max int) func(int) bool <span class="cov3" title="42">{
        return between(0, max)
}</span>

func between(min, max int) func(int) bool <span class="cov4" title="98">{
        return func(value int) bool </span><span class="cov3" title="37">{
                return value &gt;= min &amp;&amp; value &lt; max
        }</span>
}

func mapKeysToArray(values map[int]bool) []int <span class="cov3" title="34">{
        output := make([]int, len(values))
        var index int
        for key := range values </span><span class="cov3" title="45">{
                output[index] = key
                index++
        }</span>
        <span class="cov3" title="34">sort.Ints(output)
        return output</span>
}

//
// time helpers
//

func advanceYear(t time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), 1, 1, 0, 0, 0, 0, t.Location()).AddDate(1, 0, 0)
}</span>

func advanceYearTo(t time.Time, year int) time.Time <span class="cov0" title="0">{
        return time.Date(year, 1, 1, 0, 0, 0, 0, t.Location())
}</span>

func advanceMonth(t time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, t.Location()).AddDate(0, 1, 0)
}</span>

func advanceMonthTo(t time.Time, month time.Month) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), month, 1, 0, 0, 0, 0, t.Location())
}</span>

func advanceDayTo(t time.Time, day int) time.Time <span class="cov0" title="0">{
        return time.Date(t.Year(), t.Month(), day, 0, 0, 0, 0, t.Location())
}</span>

func advanceToNextSunday(t time.Time) time.Time <span class="cov1" title="3">{
        daysUntilSunday := 7 - int(t.Weekday())
        return t.AddDate(0, 0, daysUntilSunday)
}</span>

func advanceDay(t time.Time) time.Time <span class="cov1" title="2">{
        return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location()).AddDate(0, 0, 1)
}</span>

func advanceDayBy(t time.Time, days int) time.Time <span class="cov2" title="5">{
        return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location()).AddDate(0, 0, days)
}</span>

func advanceHour(t time.Time) time.Time <span class="cov1" title="4">{
        return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), 0, 0, 0, t.Location()).Add(time.Hour)
}</span>

func advanceHourTo(t time.Time, hour int) time.Time <span class="cov2" title="5">{
        return time.Date(t.Year(), t.Month(), t.Day(), hour, 0, 0, 0, t.Location())
}</span>

func advanceMinute(t time.Time) time.Time <span class="cov4" title="360">{
        return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), 0, 0, t.Location()).Add(time.Minute)
}</span>

func advanceMinuteTo(t time.Time, minute int) time.Time <span class="cov2" title="7">{
        return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), minute, 0, 0, t.Location())
}</span>

func advanceSecondTo(t time.Time, second int) time.Time <span class="cov7" title="21242">{
        return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), second, 0, t.Location())
}</span>

func csvOfInts(values []int, placeholder string) string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return placeholder
        }</span>
        <span class="cov0" title="0">valueStrings := make([]string, len(values))
        for x := 0; x &lt; len(values); x++ </span><span class="cov0" title="0">{
                valueStrings[x] = strconv.Itoa(values[x])
        }</span>
        <span class="cov0" title="0">return strings.Join(valueStrings, ",")</span>
}

// these are special characters
const (
        cronSpecialComma    = ',' //
        cronSpecialDash     = '-'
        cronSpecialStar     = '*'
        cronSpecialSlash    = '/'
        cronSpecialQuestion = '?' // sometimes used as the startup time, sometimes as a *

        cronSpecialLast       = 'L'
        cronSpecialWeekday    = 'W' // nearest weekday to the given day of the month
        cronSpecialDayOfMonth = '#' //

        cronSpecialEvery = "*/"
)

var (
        validMonths = map[string]int{
                "JAN": 1,
                "FEB": 2,
                "MAR": 3,
                "APR": 4,
                "MAY": 5,
                "JUN": 6,
                "JUL": 7,
                "AUG": 8,
                "SEP": 9,
                "OCT": 10,
                "NOV": 11,
                "DEC": 12,
        }

        validDaysOfWeek = map[string]int{
                "SUN": 0,
                "MON": 1,
                "TUE": 2,
                "WED": 3,
                "THU": 4,
                "FRI": 5,
                "SAT": 6,
        }
)
</pre>
		
		<pre class="file" id="file19" style="display: none">package cron

import "time"

// Now returns a new timestamp.
func Now() time.Time <span class="cov10" title="51">{
        return time.Now().UTC()
}</span>

// Since returns the duration since another timestamp.
func Since(t time.Time) time.Duration <span class="cov1" title="1">{
        return Now().Sub(t)
}</span>

// Min returns the minimum of two times.
func Min(t1, t2 time.Time) time.Time <span class="cov4" title="5">{
        if t1.IsZero() &amp;&amp; t2.IsZero() </span><span class="cov1" title="1">{
                return time.Time{}
        }</span>
        <span class="cov4" title="4">if t1.IsZero() </span><span class="cov1" title="1">{
                return t2
        }</span>
        <span class="cov3" title="3">if t2.IsZero() </span><span class="cov1" title="1">{
                return t1
        }</span>
        <span class="cov2" title="2">if t1.Before(t2) </span><span class="cov1" title="1">{
                return t1
        }</span>
        <span class="cov1" title="1">return t2</span>
}

// Max returns the maximum of two times.
func Max(t1, t2 time.Time) time.Time <span class="cov2" title="2">{
        if t1.Before(t2) </span><span class="cov1" title="1">{
                return t2
        }</span>
        <span class="cov1" title="1">return t1</span>
}

// FormatTime returns a string for a time.
func FormatTime(t time.Time) string <span class="cov0" title="0">{
        return t.Format(time.RFC3339)
}</span>

// NOTE: time.Zero()? what's that?
var (
        // DaysOfWeek are all the time.Weekday in an array for utility purposes.
        DaysOfWeek = []time.Weekday{
                time.Sunday,
                time.Monday,
                time.Tuesday,
                time.Wednesday,
                time.Thursday,
                time.Friday,
                time.Saturday,
        }

        // WeekDays are the business time.Weekday in an array.
        WeekDays = []time.Weekday{
                time.Monday,
                time.Tuesday,
                time.Wednesday,
                time.Thursday,
                time.Friday,
        }

        // WeekWeekEndDaysDays are the weekend time.Weekday in an array.
        WeekendDays = []time.Weekday{
                time.Sunday,
                time.Saturday,
        }

        // Epoch is unix epoch saved for utility purposes.
        Epoch = time.Unix(0, 0)
        // Zero is basically epoch but if you want to be super duper sure.
        Zero = time.Time{}
)

// NOTE: we have to use shifts here because in their infinite wisdom google didn't make these values powers of two for masking
const (
        // AllDaysMask is a bitmask of all the days of the week.
        AllDaysMask = 1&lt;&lt;uint(time.Sunday) | 1&lt;&lt;uint(time.Monday) | 1&lt;&lt;uint(time.Tuesday) | 1&lt;&lt;uint(time.Wednesday) | 1&lt;&lt;uint(time.Thursday) | 1&lt;&lt;uint(time.Friday) | 1&lt;&lt;uint(time.Saturday)
        // WeekDaysMask is a bitmask of all the weekdays of the week.
        WeekDaysMask = 1&lt;&lt;uint(time.Monday) | 1&lt;&lt;uint(time.Tuesday) | 1&lt;&lt;uint(time.Wednesday) | 1&lt;&lt;uint(time.Thursday) | 1&lt;&lt;uint(time.Friday)
        //WeekendDaysMask is a bitmask of the weekend days of the week.
        WeekendDaysMask = 1&lt;&lt;uint(time.Sunday) | 1&lt;&lt;uint(time.Saturday)
)

// IsWeekDay returns if the day is a monday-&gt;friday.
func IsWeekDay(day time.Weekday) bool <span class="cov5" title="7">{
        return !IsWeekendDay(day)
}</span>

// IsWeekendDay returns if the day is a monday-&gt;friday.
func IsWeekendDay(day time.Weekday) bool <span class="cov7" title="14">{
        return day == time.Saturday || day == time.Sunday
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
