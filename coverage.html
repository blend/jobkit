
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/blend/jobkit/config.go (28.6%)</option>
				
				<option value="file1">github.com/blend/jobkit/email.go (86.7%)</option>
				
				<option value="file2">github.com/blend/jobkit/job.go (80.3%)</option>
				
				<option value="file3">github.com/blend/jobkit/job_config.go (73.3%)</option>
				
				<option value="file4">github.com/blend/jobkit/management_server.go (77.8%)</option>
				
				<option value="file5">github.com/blend/jobkit/shell_action.go (13.0%)</option>
				
				<option value="file6">github.com/blend/jobkit/slack.go (100.0%)</option>
				
				<option value="file7">github.com/blend/jobkit/webhook.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package jobkit

import (
        "github.com/blend/go-sdk/configutil"
        "github.com/blend/go-sdk/datadog"
        "github.com/blend/go-sdk/email"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/sentry"
        "github.com/blend/go-sdk/slack"
        "github.com/blend/go-sdk/web"
)

// Config is the jobkit config.
type Config struct {
        // Title is a descriptive title for the jobkit instance.
        // It defaults to `Jobkit`
        Title string `yaml:"title"`
        // UseViewFiles indicates if we should use local view files from the disk.
        UseViewFiles *bool `yaml:"useViewFiles"`
        // Cron is the cron manager config.
        Cron JobConfig `yaml:"cron"`
        // Email sets email defaults.
        EmailDefaults email.Message `yaml:"emailDefaults"`
        // Logger is the logger config.
        Logger logger.Config `yaml:"logger"`
        // Web is the web config used for the management server.
        Web web.Config `yaml:"web"`
        // SMTP is the smtp options.
        SMTP email.SMTPSender `yaml:"smtp"`
        // Datadog configures the datadog client.
        Datadog datadog.Config `yaml:"datadog"`
        // Slack configures the slack webhook sender.
        Slack slack.Config `yaml:"slack"`
        // Sentry confgures the sentry error collector.
        Sentry sentry.Config `yaml:"sentry"`
}

// Resolve applies resolution steps to the config.
func (c *Config) Resolve() error <span class="cov0" title="0">{
        return configutil.AnyError(
                c.Logger.Resolve(),
                c.Web.Resolve(),
                c.EmailDefaults.Resolve(),
                c.Datadog.Resolve(),
                c.Slack.Resolve(),
                c.Sentry.Resolve(),
        )
}</span>

// TitleOrDefault returns a property or a default.
func (c Config) TitleOrDefault() string <span class="cov0" title="0">{
        if c.Title != "" </span><span class="cov0" title="0">{
                return c.Title
        }</span>
        <span class="cov0" title="0">return "Jobkit"</span>
}

// UseViewFilesOrDefault returns a value or a default.
func (c Config) UseViewFilesOrDefault() bool <span class="cov8" title="1">{
        if c.UseViewFiles != nil </span><span class="cov0" title="0">{
                return *c.UseViewFiles
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package jobkit

import (
        "github.com/blend/go-sdk/cron"
        "github.com/blend/go-sdk/email"
        "github.com/blend/go-sdk/template"
)

// NewEmailMessage returns a new email message.
func NewEmailMessage(flag string, emailDefaults email.Message, ji *cron.JobInvocation, options ...email.MessageOption) (email.Message, error) <span class="cov8" title="1">{
        message := email.Message{
                From: emailDefaults.From,
                To:   emailDefaults.To,
        }

        vars := map[string]interface{}{
                "flag":    flag,
                "jobName": ji.JobName,
                "state":   ji.State,
                "elapsed": ji.Elapsed,
                "err":     ji.Err,
        }
        if ji.Output != nil &amp;&amp; len(ji.Output.Chunks) &gt; 0 </span><span class="cov8" title="1">{
                vars["output"] = ji.Output.String()
        }</span>

        <span class="cov8" title="1">var err error
        message.Subject, err = template.New().WithBody(DefaultEmailSubjectTemplate).WithVars(vars).ProcessString()
        if err != nil </span><span class="cov0" title="0">{
                return message, err
        }</span>
        <span class="cov8" title="1">message.HTMLBody, err = template.New().WithBody(DefaultEmailHTMLBodyTemplate).WithVars(vars).ProcessString()
        if err != nil </span><span class="cov8" title="1">{
                return message, err
        }</span>
        <span class="cov8" title="1">message.TextBody, err = template.New().WithBody(DefaultEmailTextBodyTemplate).WithVars(vars).ProcessString()
        if err != nil </span><span class="cov0" title="0">{
                return message, err
        }</span>

        <span class="cov8" title="1">return email.ApplyMessageOptions(message, options...), nil</span>
}

const (
        // DefaultEmailMimeType is the default email mime type.
        DefaultEmailMimeType = "text/plain"

        // DefaultEmailSubjectTemplate is the default subject template.
        DefaultEmailSubjectTemplate = `{{.Var "jobName" }} :: {{ .Var "flag" }}`

        // DefaultEmailHTMLBodyTemplate is the default email html body template.
        DefaultEmailHTMLBodyTemplate = `
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;title&gt;{{ .Var "jobName" }} {{ .Var "state" "unknown" }}&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0 " /&gt;
&lt;style&gt;
.email-body {
        margin: 0;
        padding: 20px;
        font-family: sans-serif;
        font-size: 16pt;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body class="email-body"&gt;
        &lt;h3&gt;{{ .Var "jobName" }} {{ .Var "state" "Unknown" }}&lt;/h3&gt;
        &lt;div class="email-details"&gt;
        {{ if .Var "err" }}
        &lt;h4&gt;Error&lt;/h4&gt;
        &lt;pre&gt;{{ .Var "err" }}&lt;/pre&gt;
        {{ end }}
        &lt;/div&gt;
        {{ if .Var "output" }}
        &lt;h4&gt;Output&lt;/h4&gt;
        &lt;pre&gt;{{ .Var "output" }}&lt;/pre&gt;
        {{ end }}
&lt;/body&gt;
&lt;/html&gt;
`

        // DefaultEmailTextBodyTemplate is the default body template.
        DefaultEmailTextBodyTemplate = `{{ .Var "jobName" }} {{ .Var "state" }}
Elapsed: {{ .Var "elapsed" }}
{{ if .HasVar "err" }}Error: {{ .Var "err" }}{{end}}
{{ if .HasVar "output" }}Output:
{{ .Var "output" }}{{end}}
`
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package jobkit

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/blend/go-sdk/cron"
        "github.com/blend/go-sdk/email"
        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/ref"
        "github.com/blend/go-sdk/sentry"
        "github.com/blend/go-sdk/slack"
        "github.com/blend/go-sdk/stats"
        "github.com/blend/go-sdk/stringutil"
)

var (
        _ cron.Job                    = (*Job)(nil)
        _ cron.LabelsProvider         = (*Job)(nil)
        _ cron.JobConfigProvider      = (*Job)(nil)
        _ cron.ScheduleProvider       = (*Job)(nil)
        _ cron.OnStartReceiver        = (*Job)(nil)
        _ cron.OnCompleteReceiver     = (*Job)(nil)
        _ cron.OnFailureReceiver      = (*Job)(nil)
        _ cron.OnCancellationReceiver = (*Job)(nil)
        _ cron.OnBrokenReceiver       = (*Job)(nil)
        _ cron.OnFixedReceiver        = (*Job)(nil)
        _ cron.OnDisabledReceiver     = (*Job)(nil)
        _ cron.OnEnabledReceiver      = (*Job)(nil)
        _ cron.HistoryProvider        = (*Job)(nil)
)

// NewJob returns a new job.
func NewJob(cfg JobConfig, action func(context.Context) error, options ...JobOption) (*Job, error) <span class="cov8" title="1">{
        options = append([]JobOption{
                OptConfig(cfg),
                OptAction(action),
                OptParsedSchedule(cfg.ScheduleOrDefault()),
        }, options...)

        var job Job
        var err error
        for _, opt := range options </span><span class="cov8" title="1">{
                if err = opt(&amp;job); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return &amp;job, nil</span>
}

// Wrap wraps a cron job with the jobkit notifications.
func Wrap(job cron.Job) *Job <span class="cov8" title="1">{
        j := &amp;Job{
                Config: JobConfig{
                        JobConfig: cron.JobConfig{
                                Name: job.Name(),
                        },
                },
                Action: job.Execute,
        }

        if typed, ok := job.(cron.ScheduleProvider); ok </span><span class="cov8" title="1">{
                j.CompiledSchedule = typed.Schedule()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.DescriptionProvider); ok </span><span class="cov0" title="0">{
                j.Config.Description = typed.Description()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.LabelsProvider); ok </span><span class="cov8" title="1">{
                j.Config.Labels = typed.Labels()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.TimeoutProvider); ok </span><span class="cov8" title="1">{
                j.Config.Timeout = typed.Timeout()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.ShutdownGracePeriodProvider); ok </span><span class="cov8" title="1">{
                j.Config.ShutdownGracePeriod = typed.ShutdownGracePeriod()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.HistoryDisabledProvider); ok </span><span class="cov8" title="1">{
                j.Config.HistoryDisabled = ref.Bool(typed.HistoryDisabled())
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.HistoryPersistenceDisabledProvider); ok </span><span class="cov8" title="1">{
                j.Config.HistoryPersistenceDisabled = ref.Bool(typed.HistoryPersistenceDisabled())
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.HistoryMaxCountProvider); ok </span><span class="cov8" title="1">{
                j.Config.HistoryMaxCount = typed.HistoryMaxCount()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.HistoryMaxAgeProvider); ok </span><span class="cov8" title="1">{
                j.Config.HistoryMaxAge = typed.HistoryMaxAge()
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.ShouldSkipLoggerListenersProvider); ok </span><span class="cov8" title="1">{
                j.Config.ShouldSkipLoggerListeners = ref.Bool(typed.ShouldSkipLoggerListeners())
        }</span>
        <span class="cov8" title="1">if typed, ok := job.(cron.ShouldSkipLoggerOutputProvider); ok </span><span class="cov8" title="1">{
                j.Config.ShouldSkipLoggerOutput = ref.Bool(typed.ShouldSkipLoggerOutput())
        }</span>
        <span class="cov8" title="1">return j</span>
}

// OptAction sets the job action.
func OptAction(action func(context.Context) error) JobOption <span class="cov8" title="1">{
        return func(job *Job) error </span><span class="cov8" title="1">{
                job.Action = action
                return nil
        }</span>
}

// OptConfig sets the job config.
func OptConfig(cfg JobConfig) JobOption <span class="cov8" title="1">{
        return func(job *Job) error </span><span class="cov8" title="1">{
                job.Config = cfg
                job.EmailDefaults = cfg.EmailDefaults
                job.WebhookDefaults = cfg.Webhook
                return nil
        }</span>
}

// OptParsedSchedule sets the job's compiled schedule from a schedule string.
func OptParsedSchedule(schedule string) JobOption <span class="cov8" title="1">{
        return func(job *Job) error </span><span class="cov8" title="1">{
                schedule, err := cron.ParseString(schedule)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">job.CompiledSchedule = schedule
                return nil</span>
        }
}

// JobOption is an option for jobs.
type JobOption func(*Job) error

// Job is the main job body.
type Job struct {
        Config JobConfig

        CompiledSchedule cron.Schedule
        Action           func(context.Context) error

        EmailDefaults   email.Message
        WebhookDefaults Webhook

        Log          logger.Log
        StatsClient  stats.Collector
        SlackClient  slack.Sender
        SentryClient sentry.Sender
        EmailClient  email.Sender
}

// Name returns the job name.
func (job Job) Name() string <span class="cov8" title="1">{
        return job.Config.Name
}</span>

// Labels returns the job labels.
func (job Job) Labels() map[string]string <span class="cov0" title="0">{
        return job.Config.Labels
}</span>

// Schedule returns the job schedule.
func (job Job) Schedule() cron.Schedule <span class="cov0" title="0">{
        return job.CompiledSchedule
}</span>

// JobConfig returns the underlying job config.
func (job Job) JobConfig() cron.JobConfig <span class="cov0" title="0">{
        return job.Config.JobConfig
}</span>

// OnStart is a lifecycle event handler.
func (job Job) OnStart(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagStarted)
        if job.Config.NotifyOnStartOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagStarted)
        }</span>
}

// OnComplete is a lifecycle event handler.
func (job Job) OnComplete(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagComplete)
        if job.Config.NotifyOnSuccessOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagComplete)
        }</span>
}

// OnFailure is a lifecycle event handler.
func (job Job) OnFailure(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagFailed)
        if job.Config.NotifyOnFailureOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagFailed)
        }</span>
}

// OnBroken is a lifecycle event handler.
func (job Job) OnBroken(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagBroken)
        if job.Config.NotifyOnBrokenOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagBroken)
        }</span>
}

// OnFixed is a lifecycle event handler.
func (job Job) OnFixed(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagFixed)
        if job.Config.NotifyOnFixedOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagFixed)
        }</span>
}

// OnCancellation is a lifecycle event handler.
func (job Job) OnCancellation(ctx context.Context) <span class="cov8" title="1">{
        job.stats(ctx, cron.FlagCancelled)
        if job.Config.NotifyOnCancellationOrDefault() </span><span class="cov8" title="1">{
                job.notify(ctx, cron.FlagCancelled)
        }</span>
}

// OnEnabled is a lifecycle event handler.
func (job Job) OnEnabled(ctx context.Context) <span class="cov0" title="0">{
        if job.Config.NotifyOnEnabledOrDefault() </span><span class="cov0" title="0">{
                job.notify(ctx, cron.FlagEnabled)
        }</span>
}

// OnDisabled is a lifecycle event handler.
func (job Job) OnDisabled(ctx context.Context) <span class="cov0" title="0">{
        if job.Config.NotifyOnDisabledOrDefault() </span><span class="cov0" title="0">{
                job.notify(ctx, cron.FlagDisabled)
        }</span>
}

// PersistHistory writes the history to disk.
// It does so completely.
func (job Job) PersistHistory(ctx context.Context, log []cron.JobInvocation) error <span class="cov8" title="1">{
        historyDirectory := job.Config.HistoryPathOrDefault()
        if _, err := os.Stat(historyDirectory); err != nil </span><span class="cov0" title="0">{
                if err := os.MkdirAll(historyDirectory, 0755); err != nil </span><span class="cov0" title="0">{
                        return ex.New(err)
                }</span>
        }
        <span class="cov8" title="1">historyPath := filepath.Join(historyDirectory, stringutil.Slugify(job.Name())+".json")
        f, err := os.Create(historyPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        return json.NewEncoder(f).Encode(log)</span>
}

// RestoreHistory restores history from disc.
func (job Job) RestoreHistory(ctx context.Context) (output []cron.JobInvocation, err error) <span class="cov8" title="1">{
        historyPath := filepath.Join(job.Config.HistoryPathOrDefault(), stringutil.Slugify(job.Name())+".json")
        if _, statErr := os.Stat(historyPath); statErr != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var f *os.File
        f, err = os.Open(historyPath)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer f.Close()
        err = json.NewDecoder(f).Decode(&amp;output)
        return</span>
}

// Execute is the job body.
func (job Job) Execute(ctx context.Context) error <span class="cov0" title="0">{
        return job.Action(ctx)
}</span>

//
// exported utility methods
//

// Debugf logs a debug message if the logger is set.
func (job Job) Debugf(ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        if job.Log != nil </span><span class="cov0" title="0">{
                job.Log.WithPath("cron", job.Name(), cron.GetJobInvocation(ctx).ID).WithContext(ctx).Debugf(format, args...)
        }</span>
}

// Error logs an error if the logger i set.
func (job Job) Error(ctx context.Context, err error) error <span class="cov8" title="1">{
        if job.Log != nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                job.Log.WithPath("cron", job.Name(), cron.GetJobInvocation(ctx).ID).WithContext(ctx).Error(err)
        }</span>
        <span class="cov8" title="1">return err</span>

}

//
// private utility methods
//

func (job Job) stats(ctx context.Context, flag string) <span class="cov8" title="1">{
        if job.StatsClient != nil </span><span class="cov0" title="0">{
                job.StatsClient.Increment(string(flag), fmt.Sprintf("%s:%s", stats.TagJob, job.Name()))
                if ji := cron.GetJobInvocation(ctx); ji != nil </span><span class="cov0" title="0">{
                        job.Debugf(ctx, "notify (email); sending email notification")
                        job.Error(ctx, job.StatsClient.TimeInMilliseconds(string(flag), ji.Elapsed, fmt.Sprintf("%s:%s", stats.TagJob, job.Name())))
                }</span>
        } else<span class="cov8" title="1"> {
                job.Debugf(ctx, "stats client unset, skipping logging stats")
        }</span>
}

func (job Job) notify(ctx context.Context, flag string) <span class="cov8" title="1">{
        if job.SlackClient != nil </span><span class="cov8" title="1">{
                if ji := cron.GetJobInvocation(ctx); ji != nil </span><span class="cov8" title="1">{
                        job.Debugf(ctx, "notify (slack); sending slack notification")
                        job.Error(ctx, job.SlackClient.Send(context.Background(), NewSlackMessage(flag, ji)))
                }</span>
        } else<span class="cov8" title="1"> {
                job.Debugf(ctx, "notify (slack); sender unset skipping sending slack notification")
        }</span>

        <span class="cov8" title="1">if job.EmailClient != nil </span><span class="cov8" title="1">{
                if ji := cron.GetJobInvocation(ctx); ji != nil </span><span class="cov8" title="1">{
                        message, err := NewEmailMessage(flag, job.EmailDefaults, ji)
                        if err != nil </span><span class="cov8" title="1">{
                                job.Error(ctx, err)
                        }</span>
                        <span class="cov8" title="1">job.Error(ctx, job.EmailClient.Send(context.Background(), message))
                        job.Debugf(ctx, "notify (email); sent email notification to %s (%s)", stringutil.CSV(message.To), message.Subject)</span>
                } else<span class="cov0" title="0"> {
                        job.Debugf(ctx, "notify (email); job invocation not found on context")
                }</span>
        } else<span class="cov8" title="1"> {
                job.Debugf(ctx, "notify (email); email sender unset, skipping sending email notification")
        }</span>

        <span class="cov8" title="1">if !job.WebhookDefaults.IsZero() </span><span class="cov8" title="1">{
                job.Debugf(ctx, "notify (webhook); sending webhook notification")
                _, err := job.WebhookDefaults.Request().Discard()
                if err != nil </span><span class="cov0" title="0">{
                        job.Error(ctx, err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package jobkit

import (
        "github.com/blend/go-sdk/cron"
        "github.com/blend/go-sdk/email"
)

// JobConfig is something you can use to give your jobs some knobs to turn
// from configuration.
// You can use this job config by embedding it into your larger job config struct.
type JobConfig struct {
        cron.JobConfig `yaml:",inline"`
        // Schedule returns the job schedule.
        Schedule string `yaml:"schedule"`
        // HistoryPath is the base path we should write job history to.
        // The files for each job will always be $HISTORY_PATH/$NAME.json
        HistoryPath string `yaml:"historyPath"`

        // EmailDefaults holds the message defaults for email notifications.
        EmailDefaults email.Message `yaml:"emailDefaults"`

        // Webhook set a webhook target for notifications.
        Webhook Webhook `yaml:"webhook"`

        // NotifyOnStart governs if we should send notifications job start.
        NotifyOnStart *bool `yaml:"notifyOnStart"`
        // NotifyOnSuccess governs if we should send notifications on any success.
        NotifyOnSuccess *bool `yaml:"notifyOnSuccess"`
        // NotifyOnFailure governs if we should send notifications on any failure.
        NotifyOnFailure *bool `yaml:"notifyOnFailure"`
        // NotifyOnCancellation governs if we should send notifications on cancellation.
        NotifyOnCancellation *bool `yaml:"notifyOnCancellation"`
        // NotifyOnBroken governs if we should send notifications on a success =&gt; failure transition.
        NotifyOnBroken *bool `yaml:"notifyOnBroken"`
        // NotifyOnFixed governs if we should send notifications on a failure =&gt; success transition.
        NotifyOnFixed *bool `yaml:"notifyOnFixed"`
        // NotifyOnEnabled governs if we should send notifications when a job is enabled.
        NotifyOnEnabled *bool `yaml:"notifyOnEnabled"`
        // NotifyOnDisabled governs if we should send notifications when a job is disabled.
        NotifyOnDisabled *bool `yaml:"notifyOnDisabled"`
}

// ScheduleOrDefault returns the schedule or a default (every 5 minutes).
func (jc JobConfig) ScheduleOrDefault() string <span class="cov8" title="1">{
        if jc.Schedule != "" </span><span class="cov8" title="1">{
                return jc.Schedule
        }</span>
        <span class="cov0" title="0">return "* */5 * * * * *"</span>
}

// HistoryPathOrDefault returns a value or a default.
func (jc JobConfig) HistoryPathOrDefault() string <span class="cov8" title="1">{
        if jc.HistoryPath != "" </span><span class="cov8" title="1">{
                return jc.HistoryPath
        }</span>
        <span class="cov0" title="0">return DefaultHistoryPath</span>
}

// NotifyOnStartOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnStartOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnStart != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnStart
        }</span>
        <span class="cov8" title="1">return false</span>
}

// NotifyOnSuccessOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnSuccessOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnSuccess != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnSuccess
        }</span>
        <span class="cov8" title="1">return false</span>
}

// NotifyOnFailureOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnFailureOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnFailure != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnFailure
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NotifyOnCancellationOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnCancellationOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnCancellation != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnCancellation
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NotifyOnBrokenOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnBrokenOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnBroken != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnBroken
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NotifyOnFixedOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnFixedOrDefault() bool <span class="cov8" title="1">{
        if jc.NotifyOnFixed != nil </span><span class="cov8" title="1">{
                return *jc.NotifyOnFixed
        }</span>
        <span class="cov8" title="1">return true</span>
}

// NotifyOnEnabledOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnEnabledOrDefault() bool <span class="cov0" title="0">{
        if jc.NotifyOnEnabled != nil </span><span class="cov0" title="0">{
                return *jc.NotifyOnEnabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

// NotifyOnDisabledOrDefault returns a value or a default.
func (jc JobConfig) NotifyOnDisabledOrDefault() bool <span class="cov0" title="0">{
        if jc.NotifyOnDisabled != nil </span><span class="cov0" title="0">{
                return *jc.NotifyOnDisabled
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package jobkit

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/blend/go-sdk/bufferutil"
        "github.com/blend/go-sdk/stringutil"

        "github.com/blend/go-sdk/cron"
        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/selector"
        "github.com/blend/go-sdk/uuid"
        "github.com/blend/go-sdk/web"
        "github.com/blend/go-sdk/webutil"

        "github.com/blend/jobkit/static"
        "github.com/blend/jobkit/views"
)

// NewServer returns a new management server that lets you
// trigger jobs or look at job statuses via. a json api.
func NewServer(jm *cron.JobManager, cfg Config, options ...web.Option) *web.App <span class="cov8" title="1">{
        options = append([]web.Option{web.OptConfig(cfg.Web)}, options...)
        app := web.MustNew(options...)
        app.Register(ManagementServer{Cron: jm, Config: cfg})
        return app
}</span>

// ManagementServer is the jobkit management server.
type ManagementServer struct {
        Config Config
        Cron   *cron.JobManager
}

// Register registers the management server.
func (ms ManagementServer) Register(app *web.App) <span class="cov8" title="1">{
        if ms.Config.UseViewFilesOrDefault() </span><span class="cov0" title="0">{
                app.Views.LiveReload = true
                app.Views.AddPaths(ms.ViewPaths()...)
        }</span> else<span class="cov8" title="1"> {
                app.Views.LiveReload = false
                for _, viewPath := range ms.ViewPaths() </span><span class="cov8" title="1">{
                        vf, err := views.GetBinaryAsset(viewPath)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">contents, err := vf.Contents()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">app.Views.AddLiterals(string(contents))</span>
                }
        }
        <span class="cov8" title="1">app.DefaultMiddleware = append(app.DefaultMiddleware, ms.addContextStateConfig)
        app.PanicAction = func(r *web.Ctx, err interface{}) web.Result </span><span class="cov0" title="0">{
                return r.Views.InternalError(ex.New(err))
        }</span>

        // web specific routes
        <span class="cov8" title="1">app.GET("/status.json", ms.getStatus)
        app.GET("/static/*filepath", ms.getStatic)

        // manager routes
        app.GET("/", ms.getIndex)
        app.GET("/search", ms.getSearch)
        app.GET("/pause", ms.getPause)
        app.GET("/resume", ms.getResume)

        // job routes
        app.GET("/job/:jobName", ms.getJob)
        app.GET("/job.run/:jobName", ms.getJobRun)
        app.GET("/job.enable/:jobName", ms.getJobEnable)
        app.GET("/job.disable/:jobName", ms.getJobDisable)
        app.GET("/job.cancel/:jobName", ms.getJobCancel)

        // invocation routes
        app.GET("/job.invocation/:jobName/:id", ms.getJobInvocation)

        // api routes
        app.POST("/api/pause", ms.postAPIPause)
        app.POST("/api/resume", ms.postAPIResume)
        app.GET("/api/jobs", ms.getAPIJobs)
        app.GET("/api/jobs.running", ms.getAPIJobsRunning)
        app.GET("/api/job/:jobName", ms.getAPIJob)
        app.POST("/api/job.run/:jobName", ms.postAPIJobRun)
        app.POST("/api/job.cancel/:jobName", ms.postAPIJobCancel)
        app.POST("/api/job.disable/:jobName", ms.postAPIJobDisable)
        app.POST("/api/job.enable/:jobName", ms.postAPIJobEnable)
        app.GET("/api/job.invocation/:jobName/:id", ms.getAPIJobInvocation)
        app.GET("/api/job.invocation.output/:jobName/:id", ms.getAPIJobInvocationOutput)
        app.GET("/api/job.invocation.output.stream/:jobName/:id", ms.getAPIJobInvocationOutputStream)</span>
}

// ViewPaths returns the view paths for the management server.
func (ms ManagementServer) ViewPaths() []string <span class="cov8" title="1">{
        return []string{
                "_views/header.html",
                "_views/footer.html",
                "_views/index.html",
                "_views/job.html",
                "_views/invocation.html",
                "_views/partials/job_table.html",
                "_views/partials/job_row.html",
        }
}</span>

// getStatus is mapped to GET /status.json
func (ms ManagementServer) getStatus(r *web.Ctx) web.Result <span class="cov8" title="1">{
        return web.JSON.Result(ms.Cron.Status())
}</span>

// getStatic is mapped to GET /static/*filepath
func (ms ManagementServer) getStatic(r *web.Ctx) web.Result <span class="cov8" title="1">{
        path, err := r.RouteParam("filepath")
        if err != nil </span><span class="cov0" title="0">{
                web.Text.NotFound()
        }</span>
        <span class="cov8" title="1">path = filepath.Join("_static", path)
        file, err := static.GetBinaryAsset(path)
        if err == os.ErrNotExist </span><span class="cov0" title="0">{
                return web.Text.NotFound()
        }</span>
        <span class="cov8" title="1">contents, err := file.Contents()
        if err != nil </span><span class="cov0" title="0">{
                return web.Text.InternalError(err)
        }</span>
        <span class="cov8" title="1">http.ServeContent(r.Response, r.Request, path, time.Unix(file.ModTime, 0), bytes.NewReader(contents))
        return nil</span>
}

//
// api or view routes
//

// getIndex is mapped to GET /
func (ms ManagementServer) getIndex(r *web.Ctx) web.Result <span class="cov8" title="1">{
        r.State.Set("show-job-history-link", true)
        return r.Views.View("index", ms.Cron.Status().Jobs)
}</span>

// getIndex is mapped to GET /search?selector=&lt;SELECTOR&gt;
func (ms ManagementServer) getSearch(r *web.Ctx) web.Result <span class="cov8" title="1">{
        selectorParam := web.StringValue(r.QueryValue("selector"))
        if selectorParam == "" </span><span class="cov0" title="0">{
                return web.RedirectWithMethod("GET", "/")
        }</span>
        <span class="cov8" title="1">sel, err := selector.Parse(selectorParam)
        if err != nil </span><span class="cov8" title="1">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">r.State.Set("selector", sel.String())

        status := ms.Cron.Status()
        status.Jobs = ms.filterJobSchedulers(status.Jobs, func(js cron.JobSchedulerStatus) bool </span><span class="cov8" title="1">{
                return sel.Matches(js.Labels)
        }</span>)
        <span class="cov8" title="1">r.State.Set("show-job-history-link", true)
        return r.Views.View("index", status.Jobs)</span>
}

// getPause is mapped to GET /pause
func (ms ManagementServer) getPause(r *web.Ctx) web.Result <span class="cov8" title="1">{
        if err := ms.Cron.Stop(); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethod("GET", "/")</span>
}

// getResume is mapped to GET /resume
func (ms ManagementServer) getResume(r *web.Ctx) web.Result <span class="cov8" title="1">{
        if err := ms.Cron.StartAsync(); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethod("GET", "/")</span>
}

// getJob is mapped to GET /job/:jobName
func (ms ManagementServer) getJob(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov8" title="1">{
                return result
        }</span>
        <span class="cov8" title="1">return r.Views.View("job", job)</span>
}

// getJobRun is mapped to GET /job.run/:jobName
func (ms ManagementServer) getJobRun(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">ji, err := ms.Cron.RunJob(job.Name())
        if err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethodf("GET", "/job.invocation/%s/%s", url.QueryEscape(job.Name()), ji.ID)</span>
}

// getJobEnable is mapped to GET /job.enable/:jobName
func (ms ManagementServer) getJobEnable(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">if err := ms.Cron.EnableJobs(job.Name()); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethod("GET", "/")</span>
}

// getJobDisable is mapped to GET /job.disable/:jobName
func (ms ManagementServer) getJobDisable(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">if err := ms.Cron.DisableJobs(job.Name()); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethod("GET", "/")</span>
}

// getJobCancel is mapped to GET /job.cancel;/:jobName
func (ms ManagementServer) getJobCancel(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">err := ms.Cron.CancelJob(job.Name())
        if err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.RedirectWithMethod("GET", "/")</span>
}

// getJobInvocation is mapped to GET /job.invocation/:jobName/:id
func (ms ManagementServer) getJobInvocation(r *web.Ctx) web.Result <span class="cov8" title="1">{
        invocation, result := ms.getRequestJobInvocation(r, r.Views)
        if result != nil </span><span class="cov8" title="1">{
                return result
        }</span>
        <span class="cov8" title="1">return r.Views.View("invocation", invocation)</span>
}

// getAPIJobs is mapped to GET /api/jobs
func (ms ManagementServer) getAPIJobs(r *web.Ctx) web.Result <span class="cov8" title="1">{
        return web.JSON.Result(ms.Cron.Status().Jobs)
}</span>

// getAPIJobs is mapped to GET /api/jobs.running
func (ms ManagementServer) getAPIJobsRunning(r *web.Ctx) web.Result <span class="cov8" title="1">{
        return web.JSON.Result(ms.Cron.Status().Running)
}</span>

// postAPIPause is mapped to POST /api/pause
func (ms ManagementServer) postAPIPause(r *web.Ctx) web.Result <span class="cov8" title="1">{
        if err := ms.Cron.Stop(); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.OK()</span>
}

// postAPIResume is mapped to POST /api/resume
func (ms ManagementServer) postAPIResume(r *web.Ctx) web.Result <span class="cov8" title="1">{
        if err := ms.Cron.StartAsync(); err != nil </span><span class="cov0" title="0">{
                return r.Views.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.OK()</span>
}

// getAPIJob is mapped to GET /api/job/:jobName
func (ms ManagementServer) getAPIJob(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov8" title="1">{
                return result
        }</span>
        <span class="cov8" title="1">return web.JSON.Result(job.Status())</span>
}

// postAPIJobRun is mapped to POST /api/job.run/:jobName
func (ms ManagementServer) postAPIJobRun(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">ji, err := ms.Cron.RunJob(job.Name())
        if err != nil </span><span class="cov0" title="0">{
                return web.JSON.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.Result(ji)</span>
}

// postAPIJobCancel is mapped to POST /api/job.cancel/:jobName
func (ms ManagementServer) postAPIJobCancel(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">if err := ms.Cron.CancelJob(job.Name()); err != nil </span><span class="cov0" title="0">{
                return web.JSON.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.OK()</span>
}

// postAPIJobDisable is mapped to POST /api/job.disable/:jobName
func (ms ManagementServer) postAPIJobDisable(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">if err := ms.Cron.DisableJobs(job.Name()); err != nil </span><span class="cov0" title="0">{
                return web.JSON.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.OK()</span>
}

// postAPIJobEnable is mapped to POST /api/job.enable/:jobName
func (ms ManagementServer) postAPIJobEnable(r *web.Ctx) web.Result <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">if err := ms.Cron.EnableJobs(job.Name()); err != nil </span><span class="cov0" title="0">{
                return web.JSON.BadRequest(err)
        }</span>
        <span class="cov8" title="1">return web.JSON.Result(fmt.Sprintf("%s enabled", job.Name()))</span>
}

// getAPIJobInvocation is mapped to GET /api/job.invocation/:jobName/:id
func (ms ManagementServer) getAPIJobInvocation(r *web.Ctx) web.Result <span class="cov8" title="1">{
        invocation, result := ms.getRequestJobInvocation(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">return web.JSON.Result(invocation)</span>
}

func (ms ManagementServer) getAPIJobInvocationOutput(r *web.Ctx) web.Result <span class="cov8" title="1">{
        invocation, result := ms.getRequestJobInvocation(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">chunks := invocation.Output.Chunks
        if afterNanos, _ := web.Int64Value(r.QueryValue("afterNanos")); afterNanos &gt; 0 </span><span class="cov8" title="1">{
                afterTS := time.Unix(0, afterNanos)

                var filtered []bufferutil.BufferChunk
                for _, chunk := range chunks </span><span class="cov8" title="1">{
                        if chunk.Timestamp.After(afterTS) </span><span class="cov8" title="1">{
                                filtered = append(filtered, chunk)
                        }</span>
                }
                <span class="cov8" title="1">return web.JSON.Result(map[string]interface{}{
                        "serverTimeNanos": time.Now().UTC().UnixNano(),
                        "chunks":          filtered,
                })</span>
        }
        <span class="cov8" title="1">return web.JSON.Result(map[string]interface{}{
                "serverTimeNanos": time.Now().UTC().UnixNano(),
                "chunks":          chunks,
        })</span>
}

func (ms ManagementServer) getAPIJobInvocationOutputStream(r *web.Ctx) web.Result <span class="cov8" title="1">{
        log := r.App.Log

        invocation, result := ms.getRequestJobInvocation(r, web.JSON)
        if result != nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov8" title="1">es := webutil.EventSource{Output: r.Response}
        if err := es.StartSession(); err != nil </span><span class="cov0" title="0">{
                logger.MaybeError(log, err)
                return nil
        }</span>

        <span class="cov8" title="1">if !ms.Cron.IsJobRunning(invocation.JobName) </span><span class="cov8" title="1">{
                logger.MaybeDebugf(log, "output stream; job is not running, closing")
                if err := es.EventData("complete", string(invocation.State)); err != nil </span><span class="cov0" title="0">{
                        logger.MaybeError(log, err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">sendOutputData := func(chunk bufferutil.BufferChunk) </span><span class="cov8" title="1">{
                for _, line := range stringutil.SplitLines(string(chunk.Data),
                        stringutil.OptSplitLinesIncludeNewLine(true),
                        stringutil.OptSplitLinesIncludeEmptyLines(true),
                ) </span><span class="cov8" title="1">{
                        contents, _ := json.Marshal(map[string]interface{}{"data": strings.TrimSuffix(line, "\n")})
                        if strings.HasSuffix(line, "\n") </span><span class="cov8" title="1">{
                                if err := es.EventData("writeln", string(contents)); err != nil </span><span class="cov0" title="0">{
                                        logger.MaybeError(log, err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if err := es.EventData("write", string(contents)); err != nil </span><span class="cov0" title="0">{
                                        logger.MaybeError(log, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">listenerID := uuid.V4().String()
        // include catchup chunks
        if afterNanos, _ := web.Int64Value(r.QueryValue("afterNanos")); afterNanos &gt; 0 </span><span class="cov0" title="0">{
                after := time.Unix(0, afterNanos)
                logger.MaybeDebugf(log, "output stream; sending catchup output stream data from: %v", after)
                for _, chunk := range invocation.Output.Chunks </span><span class="cov0" title="0">{
                        if chunk.Timestamp.After(after) </span><span class="cov0" title="0">{
                                sendOutputData(chunk)
                        }</span>
                }
        }

        <span class="cov8" title="1">logger.MaybeDebugf(log, "output stream; listening for new chunks")
        invocation.OutputHandlers.Add(listenerID, func(chunk bufferutil.BufferChunk) </span><span class="cov8" title="1">{
                sendOutputData(chunk)
        }</span>)
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ invocation.OutputHandlers.Remove(listenerID) }</span>()

        <span class="cov8" title="1">updateTick := time.Tick(100 * time.Millisecond)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-updateTick:<span class="cov8" title="1">
                        if !ms.Cron.IsJobRunning(invocation.JobName) </span><span class="cov8" title="1">{
                                logger.MaybeDebugf(log, "output stream; job invocation is complete, closing")
                                if err := es.EventData("complete", string(invocation.State)); err != nil </span><span class="cov0" title="0">{
                                        logger.MaybeError(log, err)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }
                        <span class="cov0" title="0">if err := es.Ping(); err != nil </span><span class="cov0" title="0">{
                                logger.MaybeError(log, err)
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err := es.EventData("elapsed", fmt.Sprintf("%v", time.Now().UTC().Sub(invocation.Started).Round(time.Millisecond))); err != nil </span><span class="cov0" title="0">{
                                logger.MaybeError(log, err)
                                return nil
                        }</span>
                }
        }
}

// addContextStateConfig is a middleware that adds the config to a request context's state.
func (ms ManagementServer) addContextStateConfig(action web.Action) web.Action <span class="cov8" title="1">{
        return func(r *web.Ctx) web.Result </span><span class="cov8" title="1">{
                r.State.Set("config", ms.Config)
                return action(r)
        }</span>
}

func (ms ManagementServer) getRequestJob(r *web.Ctx, resultProvider web.ResultProvider) (*cron.JobScheduler, web.Result) <span class="cov8" title="1">{
        jobName, err := r.RouteParam("jobName")
        if err != nil </span><span class="cov0" title="0">{
                return nil, resultProvider.BadRequest(err)
        }</span>
        <span class="cov8" title="1">jobName, err = url.QueryUnescape(jobName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resultProvider.BadRequest(err)
        }</span>
        <span class="cov8" title="1">job, err := ms.Cron.Job(jobName)
        if err != nil || job == nil </span><span class="cov8" title="1">{
                return nil, resultProvider.NotFound()
        }</span>
        <span class="cov8" title="1">return job, nil</span>
}

// getRequestJobInvocation pulls a job invocation off a request context.
func (ms ManagementServer) getRequestJobInvocation(r *web.Ctx, resultProvider web.ResultProvider) (*cron.JobInvocation, web.Result) <span class="cov8" title="1">{
        job, result := ms.getRequestJob(r, resultProvider)
        if result != nil </span><span class="cov8" title="1">{
                return nil, result
        }</span>

        <span class="cov8" title="1">invocationID, err := r.RouteParam("id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, resultProvider.BadRequest(err)
        }</span>

        <span class="cov8" title="1">if invocationID == "current" &amp;&amp; job.Current != nil </span><span class="cov8" title="1">{
                return job.Current, nil
        }</span>
        <span class="cov8" title="1">if invocationID == "last" &amp;&amp; job.Last != nil </span><span class="cov0" title="0">{
                return job.Last, nil
        }</span>

        <span class="cov8" title="1">invocation := job.JobInvocation(invocationID)
        if invocation == nil </span><span class="cov8" title="1">{
                return nil, resultProvider.NotFound()
        }</span>
        <span class="cov8" title="1">return invocation, nil</span>
}

func (ms ManagementServer) filterJobSchedulers(schedulers []cron.JobSchedulerStatus, predicate func(cron.JobSchedulerStatus) bool) []cron.JobSchedulerStatus <span class="cov8" title="1">{
        var output []cron.JobSchedulerStatus
        for _, js := range schedulers </span><span class="cov8" title="1">{
                if predicate(js) </span><span class="cov8" title="1">{
                        output = append(output, js)
                }</span>
        }
        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package jobkit

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/blend/go-sdk/cron"

        "github.com/blend/go-sdk/ex"
        "github.com/blend/go-sdk/sh"
)

// ShellActionOption mutates a ShellActionOptions object.
type ShellActionOption func(*ShellActionOptions)

// OptShellActionDiscardOutput sets the `Discard` field on the options.
func OptShellActionDiscardOutput(discard bool) ShellActionOption <span class="cov0" title="0">{
        return func(opts *ShellActionOptions) </span><span class="cov0" title="0">{ opts.DiscardOutput = discard }</span>
}

// OptShellActionSkipExpandEnv sets if ShellAction should skip expanding env values.
func OptShellActionSkipExpandEnv(SkipExpandEnv bool) ShellActionOption <span class="cov0" title="0">{
        return func(opts *ShellActionOptions) </span><span class="cov0" title="0">{ opts.SkipExpandEnv = SkipExpandEnv }</span>
}

// ShellActionOptions captures options for a shell action.
type ShellActionOptions struct {
        SkipExpandEnv bool `yaml:"skipExpandEnv"`
        DiscardOutput bool `yaml:"discardOutput"`
}

// ShellAction creates a new shell action.
func ShellAction(exec []string, opts ...ShellActionOption) func(context.Context) error <span class="cov8" title="1">{
        var options ShellActionOptions
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;options)
        }</span>

        <span class="cov8" title="1">return func(ctx context.Context) error </span><span class="cov0" title="0">{
                ji := cron.GetJobInvocation(ctx)
                if ji == nil || ji.Output == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("shell action; invocation meta required with the output set")
                }</span>
                <span class="cov0" title="0">if !options.SkipExpandEnv </span><span class="cov0" title="0">{
                        for index, arg := range exec </span><span class="cov0" title="0">{
                                if index == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">exec[index] = os.ExpandEnv(arg)</span>
                        }
                }
                <span class="cov0" title="0">cmd, err := sh.CmdContext(ctx, exec[0], exec[1:]...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !options.DiscardOutput </span><span class="cov0" title="0">{
                        cmd.Stdout = io.MultiWriter(ji.Output, os.Stdout)
                        cmd.Stderr = io.MultiWriter(ji.Output, os.Stderr)
                }</span>
                <span class="cov0" title="0">return ex.New(cmd.Run())</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package jobkit

import (
        "fmt"

        "github.com/blend/go-sdk/cron"
        "github.com/blend/go-sdk/slack"
)

// NewSlackMessage returns a new job started message.
func NewSlackMessage(flag string, ji *cron.JobInvocation, options ...slack.MessageOption) slack.Message <span class="cov8" title="1">{
        message := slack.Message{}
        if ji.Err != nil </span><span class="cov8" title="1">{
                message.Attachments = append(message.Attachments,
                        slack.MessageAttachment{
                                Text:  fmt.Sprintf("%s %s", ji.JobName, flag),
                                Color: "#ff0000",
                        },
                        slack.MessageAttachment{
                                Text:  fmt.Sprintf("error: %+v", ji.Err),
                                Color: "#ff0000",
                        },
                )
        }</span> else<span class="cov8" title="1"> {
                message.Attachments = append(message.Attachments,
                        slack.MessageAttachment{
                                Text:  fmt.Sprintf("%s %s", ji.JobName, flag),
                                Color: "#00ff00",
                        },
                )
        }</span>

        <span class="cov8" title="1">if ji.Elapsed &gt; 0 </span><span class="cov8" title="1">{
                message.Attachments = append(message.Attachments,
                        slack.MessageAttachment{
                                Text: fmt.Sprintf("%v elapsed", ji.Elapsed),
                        },
                )
        }</span>

        <span class="cov8" title="1">return slack.ApplyMessageOptions(message, options...)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package jobkit

import (
        "net/http"

        "github.com/blend/go-sdk/r2"
)

// Webhook is a notification type.
type Webhook struct {
        Method  string            `yaml:"method"`
        URL     string            `yaml:"url"`
        Headers map[string]string `yaml:"headers"`
        Body    string            `yaml:"body"`
}

// IsZero returns if the webhook is set or not.
func (wh Webhook) IsZero() bool <span class="cov8" title="1">{
        return wh.URL == ""
}</span>

// Request creates a new r2 request for the webhook.
func (wh Webhook) Request() *r2.Request <span class="cov8" title="1">{
        return r2.New(wh.URL, wh.Options()...)
}</span>

// Options realizes the webhook as a set of r2 options.
func (wh Webhook) Options() []r2.Option <span class="cov8" title="1">{
        options := []r2.Option{
                r2.OptMethod(wh.MethodOrDefault()),
        }
        if len(wh.Headers) &gt; 0 </span><span class="cov8" title="1">{
                for key, value := range wh.Headers </span><span class="cov8" title="1">{
                        options = append(options, r2.OptHeaderValue(http.CanonicalHeaderKey(key), value))
                }</span>
        }
        <span class="cov8" title="1">if wh.Body != "" </span><span class="cov8" title="1">{
                options = append(options, r2.OptBodyBytes([]byte(wh.Body)))
        }</span>
        <span class="cov8" title="1">return options</span>
}

// MethodOrDefault returns the webhoook method.
func (wh Webhook) MethodOrDefault() string <span class="cov8" title="1">{
        if wh.Method != "" </span><span class="cov8" title="1">{
                return wh.Method
        }</span>
        <span class="cov8" title="1">return r2.MethodGet</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
